{"version":3,"file":"r3_factory.js","sourceRoot":"","sources":["../../../../../packages/compiler/src/render3/r3_factory.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from '../aot/static_symbol';\nimport {CompileTypeMetadata, tokenReference} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {InjectFlags} from '../core';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\nimport {Identifiers as R3} from '../render3/r3_identifiers';\nimport {OutputContext} from '../util';\n\nimport {unsupported} from './view/util';\n\n/**\n * Metadata required by the factory generator to generate a `factory` function for a type.\n */\nexport interface R3FactoryMetadata {\n  /**\n   * String name of the type being generated (used to name the factory function).\n   */\n  name: string;\n\n  /**\n   * An expression representing the function (or constructor) which will instantiate the requested\n   * type.\n   *\n   * This could be a reference to a constructor type, or to a user-defined factory function. The\n   * `useNew` property determines whether it will be called as a constructor or not.\n   */\n  fnOrClass: o.Expression;\n\n  /**\n   * Regardless of whether `fnOrClass` is a constructor function or a user-defined factory, it\n   * may have 0 or more parameters, which will be injected according to the `R3DependencyMetadata`\n   * for those parameters.\n   */\n  deps: R3DependencyMetadata[];\n\n  /**\n   * Whether to interpret `fnOrClass` as a constructor function (`useNew: true`) or as a factory\n   * (`useNew: false`).\n   */\n  useNew: boolean;\n\n\n  /**\n   * An expression for the function which will be used to inject dependencies. The API of this\n   * function could be different, and other options control how it will be invoked.\n   */\n  injectFn: o.ExternalReference;\n}\n\n/**\n * Resolved type of a dependency.\n *\n * Occasionally, dependencies will have special significance which is known statically. In that\n * case the `R3ResolvedDependencyType` informs the factory generator that a particular dependency\n * should be generated specially (usually by calling a special injection function instead of the\n * standard one).\n */\nexport enum R3ResolvedDependencyType {\n  /**\n   * A normal token dependency.\n   */\n  Token = 0,\n\n  /**\n   * The dependency is for an attribute.\n   *\n   * The token expression is a string representing the attribute name.\n   */\n  Attribute = 1,\n\n  /**\n   * The dependency is for the `Injector` type itself.\n   */\n  Injector = 2,\n\n  /**\n   * The dependency is for `ElementRef`.\n   */\n  ElementRef = 3,\n\n  /**\n   * The dependency is for `TemplateRef`.\n   */\n  TemplateRef = 4,\n\n  /**\n   * The dependency is for `ViewContainerRef`.\n   */\n  ViewContainerRef = 5,\n\n  /**\n   * The dependency is for `ChangeDetectorRef`.\n   */\n  ChangeDetectorRef = 6,\n}\n\n/**\n * Metadata representing a single dependency to be injected into a constructor or function call.\n */\nexport interface R3DependencyMetadata {\n  /**\n   * An expression representing the token or value to be injected.\n   */\n  token: o.Expression;\n\n  /**\n   * An enum indicating whether this dependency has special meaning to Angular and needs to be\n   * injected specially.\n   */\n  resolved: R3ResolvedDependencyType;\n\n  /**\n   * Whether the dependency has an @Host qualifier.\n   */\n  host: boolean;\n\n  /**\n   * Whether the dependency has an @Optional qualifier.\n   */\n  optional: boolean;\n\n  /**\n   * Whether the dependency has an @Self qualifier.\n   */\n  self: boolean;\n\n  /**\n   * Whether the dependency has an @SkipSelf qualifier.\n   */\n  skipSelf: boolean;\n}\n\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nexport function compileFactoryFunction(meta: R3FactoryMetadata): o.Expression {\n  // Each dependency becomes an invocation of an inject*() function.\n  const args = meta.deps.map(dep => compileInjectDependency(dep, meta.injectFn));\n\n  // The overall result depends on whether this is construction or function invocation.\n  const expr = meta.useNew ? new o.InstantiateExpr(meta.fnOrClass, args) :\n                             new o.InvokeFunctionExpr(meta.fnOrClass, args);\n\n  return o.fn(\n      [], [new o.ReturnStatement(expr)], o.INFERRED_TYPE, undefined, `${meta.name}_Factory`);\n}\n\nfunction compileInjectDependency(\n    dep: R3DependencyMetadata, injectFn: o.ExternalReference): o.Expression {\n  // Interpret the dependency according to its resolved type.\n  switch (dep.resolved) {\n    case R3ResolvedDependencyType.Token:\n    case R3ResolvedDependencyType.Injector: {\n      // Build up the injection flags according to the metadata.\n      const flags = InjectFlags.Default | (dep.self ? InjectFlags.Self : 0) |\n          (dep.skipSelf ? InjectFlags.SkipSelf : 0) | (dep.host ? InjectFlags.Host : 0) |\n          (dep.optional ? InjectFlags.Optional : 0);\n      // Determine the token used for injection. In almost all cases this is the given token, but\n      // if the dependency is resolved to the `Injector` then the special `INJECTOR` token is used\n      // instead.\n      let token: o.Expression = dep.token;\n      if (dep.resolved === R3ResolvedDependencyType.Injector) {\n        token = o.importExpr(Identifiers.INJECTOR);\n      }\n\n      // Build up the arguments to the injectFn call.\n      const injectArgs = [token];\n      // If this dependency is optional or otherwise has non-default flags, then additional\n      // parameters describing how to inject the dependency must be passed to the inject function\n      // that's being used.\n      if (flags !== InjectFlags.Default || dep.optional) {\n        injectArgs.push(o.literal(flags));\n      }\n      return o.importExpr(injectFn).callFn(injectArgs);\n    }\n    case R3ResolvedDependencyType.Attribute:\n      // In the case of attributes, the attribute name in question is given as the token.\n      return o.importExpr(R3.injectAttribute).callFn([dep.token]);\n    case R3ResolvedDependencyType.ElementRef:\n      return o.importExpr(R3.injectElementRef).callFn([]);\n    case R3ResolvedDependencyType.TemplateRef:\n      return o.importExpr(R3.injectTemplateRef).callFn([]);\n    case R3ResolvedDependencyType.ViewContainerRef:\n      return o.importExpr(R3.injectViewContainerRef).callFn([]);\n    case R3ResolvedDependencyType.ChangeDetectorRef:\n      return o.importExpr(R3.injectChangeDetectorRef).callFn([]);\n    default:\n      return unsupported(\n          `Unknown R3ResolvedDependencyType: ${R3ResolvedDependencyType[dep.resolved]}`);\n  }\n}\n\n/**\n * A helper function useful for extracting `R3DependencyMetadata` from a Render2\n * `CompileTypeMetadata` instance.\n */\nexport function dependenciesFromGlobalMetadata(\n    type: CompileTypeMetadata, outputCtx: OutputContext,\n    reflector: CompileReflector): R3DependencyMetadata[] {\n  // Use the `CompileReflector` to look up references to some well-known Angular types. These will\n  // be compared with the token to statically determine whether the token has significance to\n  // Angular, and set the correct `R3ResolvedDependencyType` as a result.\n  const elementRef = reflector.resolveExternalReference(Identifiers.ElementRef);\n  const templateRef = reflector.resolveExternalReference(Identifiers.TemplateRef);\n  const viewContainerRef = reflector.resolveExternalReference(Identifiers.ViewContainerRef);\n  const injectorRef = reflector.resolveExternalReference(Identifiers.Injector);\n\n  // Iterate through the type's DI dependencies and produce `R3DependencyMetadata` for each of them.\n  const deps: R3DependencyMetadata[] = [];\n  for (let dependency of type.diDeps) {\n    if (dependency.token) {\n      const tokenRef = tokenReference(dependency.token);\n      let resolved: R3ResolvedDependencyType = R3ResolvedDependencyType.Token;\n      if (tokenRef === elementRef) {\n        resolved = R3ResolvedDependencyType.ElementRef;\n      } else if (tokenRef === templateRef) {\n        resolved = R3ResolvedDependencyType.TemplateRef;\n      } else if (tokenRef === viewContainerRef) {\n        resolved = R3ResolvedDependencyType.ViewContainerRef;\n      } else if (tokenRef === injectorRef) {\n        resolved = R3ResolvedDependencyType.Injector;\n      } else if (dependency.isAttribute) {\n        resolved = R3ResolvedDependencyType.Attribute;\n      }\n\n      // In the case of most dependencies, the token will be a reference to a type. Sometimes,\n      // however, it can be a string, in the case of older Angular code or @Attribute injection.\n      const token =\n          tokenRef instanceof StaticSymbol ? outputCtx.importExpr(tokenRef) : o.literal(tokenRef);\n\n      // Construct the dependency.\n      deps.push({\n        token,\n        resolved,\n        host: !!dependency.isHost,\n        optional: !!dependency.isOptional,\n        self: !!dependency.isSelf,\n        skipSelf: !!dependency.isSkipSelf,\n      });\n    } else {\n      unsupported('dependency without a token');\n    }\n  }\n\n  return deps;\n}\n"]}