{"version":3,"file":"injectable_compiler_2.js","sourceRoot":"","sources":["../../../../packages/compiler/src/injectable_compiler_2.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectFlags} from './core';\nimport {Identifiers} from './identifiers';\nimport * as o from './output/output_ast';\nimport {R3DependencyMetadata, compileFactoryFunction} from './render3/r3_factory';\nimport {mapToMapExpression} from './render3/util';\n\nexport interface InjectableDef {\n  expression: o.Expression;\n  type: o.Type;\n}\n\nexport interface R3InjectableMetadata {\n  name: string;\n  type: o.Expression;\n  providedIn: o.Expression;\n  useClass?: o.Expression;\n  useFactory?: o.Expression;\n  useExisting?: o.Expression;\n  useValue?: o.Expression;\n  deps?: R3DependencyMetadata[];\n}\n\nexport function compileInjectable(meta: R3InjectableMetadata): InjectableDef {\n  let factory: o.Expression = o.NULL_EXPR;\n\n  function makeFn(ret: o.Expression): o.Expression {\n    return o.fn([], [new o.ReturnStatement(ret)], undefined, undefined, `${meta.name}_Factory`);\n  }\n\n  if (meta.useClass !== undefined || meta.useFactory !== undefined) {\n    // First, handle useClass and useFactory together, since both involve a similar call to\n    // `compileFactoryFunction`. Either dependencies are explicitly specified, in which case\n    // a factory function call is generated, or they're not specified and the calls are special-\n    // cased.\n    if (meta.deps !== undefined) {\n      // Either call `new meta.useClass(...)` or `meta.useFactory(...)`.\n      const fnOrClass: o.Expression = meta.useClass || meta.useFactory !;\n\n      // useNew: true if meta.useClass, false for meta.useFactory.\n      const useNew = meta.useClass !== undefined;\n\n      factory = compileFactoryFunction({\n        name: meta.name,\n        fnOrClass,\n        useNew,\n        injectFn: Identifiers.inject,\n        deps: meta.deps,\n      });\n    } else if (meta.useClass !== undefined) {\n      // Special case for useClass where the factory from the class's ngInjectableDef is used.\n      if (meta.useClass.isEquivalent(meta.type)) {\n        // For the injectable compiler, useClass represents a foreign type that should be\n        // instantiated to satisfy construction of the given type. It's not valid to specify\n        // useClass === type, since the useClass type is expected to already be compiled.\n        throw new Error(\n            `useClass is the same as the type, but no deps specified, which is invalid.`);\n      }\n      factory =\n          makeFn(new o.ReadPropExpr(new o.ReadPropExpr(meta.useClass, 'ngInjectableDef'), 'factory')\n                     .callFn([]));\n    } else if (meta.useFactory !== undefined) {\n      // Special case for useFactory where no arguments are passed.\n      factory = meta.useFactory.callFn([]);\n    } else {\n      // Can't happen - outer conditional guards against both useClass and useFactory being\n      // undefined.\n      throw new Error('Reached unreachable block in injectable compiler.');\n    }\n  } else if (meta.useValue !== undefined) {\n    // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n    // client code because meta.useValue is an Expression which will be defined even if the actual\n    // value is undefined.\n    factory = makeFn(meta.useValue);\n  } else if (meta.useExisting !== undefined) {\n    // useExisting is an `inject` call on the existing token.\n    factory = makeFn(o.importExpr(Identifiers.inject).callFn([meta.useExisting]));\n  } else {\n    // A strict type is compiled according to useClass semantics, except the dependencies are\n    // required.\n    if (meta.deps === undefined) {\n      throw new Error(`Type compilation of an injectable requires dependencies.`);\n    }\n    factory = compileFactoryFunction({\n      name: meta.name,\n      fnOrClass: meta.type,\n      useNew: true,\n      injectFn: Identifiers.inject,\n      deps: meta.deps,\n    });\n  }\n\n  const token = meta.type;\n  const providedIn = meta.providedIn;\n\n  const expression = o.importExpr(Identifiers.defineInjectable).callFn([mapToMapExpression(\n      {token, factory, providedIn})]);\n  const type = new o.ExpressionType(\n      o.importExpr(Identifiers.InjectableDef, [new o.ExpressionType(meta.type)]));\n\n  return {\n      expression, type,\n  };\n}\n"]}