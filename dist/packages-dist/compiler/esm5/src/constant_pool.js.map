{"version":3,"file":"constant_pool.js","sourceRoot":"","sources":["../../../../../packages/compiler/src/constant_pool.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\nimport {OutputContext, error} from './util';\n\nconst CONSTANT_PREFIX = '_c';\n\n// Closure variables holding messages must be named `MSG_[A-Z0-9]+`\nconst TRANSLATION_PREFIX = 'MSG_';\n\nexport const enum DefinitionKind {Injector, Directive, Component, Pipe}\n\n/**\n * Closure uses `goog.getMsg(message)` to lookup translations\n */\nconst GOOG_GET_MSG = 'goog.getMsg';\n\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends o.Expression {\n  private original: o.Expression;\n\n  // TODO(issue/24571): remove '!'.\n  shared !: boolean;\n\n  constructor(public resolved: o.Expression) {\n    super(resolved.type);\n    this.original = resolved;\n  }\n\n  visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (context === KEY_CONTEXT) {\n      // When producing a key we want to traverse the constant not the\n      // variable used to refer to it.\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n\n  isEquivalent(e: o.Expression): boolean {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n\n  isConstant() { return true; }\n\n  fixup(expression: o.Expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\n\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nexport class ConstantPool {\n  statements: o.Statement[] = [];\n  private translations = new Map<string, o.Expression>();\n  private literals = new Map<string, FixupExpression>();\n  private literalFactories = new Map<string, o.Expression>();\n  private injectorDefinitions = new Map<any, FixupExpression>();\n  private directiveDefinitions = new Map<any, FixupExpression>();\n  private componentDefinitions = new Map<any, FixupExpression>();\n  private pipeDefinitions = new Map<any, FixupExpression>();\n\n  private nextNameIndex = 0;\n\n  getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression {\n    if (literal instanceof o.LiteralExpr || literal instanceof FixupExpression) {\n      // Do no put simple literals into the constant pool or try to produce a constant for a\n      // reference to a constant.\n      return literal;\n    }\n    const key = this.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      // Replace the expression with a variable\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(literal).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(o.variable(name));\n    }\n\n    return fixup;\n  }\n\n  // Generates closure specific code for translation.\n  //\n  // ```\n  // /**\n  //  * @desc description?\n  //  * @meaning meaning?\n  //  */\n  // const MSG_XYZ = goog.getMsg('message');\n  // ```\n  getTranslation(message: string, meta: {description?: string, meaning?: string}): o.Expression {\n    // The identity of an i18n message depends on the message and its meaning\n    const key = meta.meaning ? `${message}\\u0000\\u0000${meta.meaning}` : message;\n\n    const exp = this.translations.get(key);\n\n    if (exp) {\n      return exp;\n    }\n\n    const docStmt = i18nMetaToDocStmt(meta);\n    if (docStmt) {\n      this.statements.push(docStmt);\n    }\n\n    // Call closure to get the translation\n    const variable = o.variable(this.freshTranslationName());\n    const fnCall = o.variable(GOOG_GET_MSG).callFn([o.literal(message)]);\n    const msgStmt = variable.set(fnCall).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]);\n    this.statements.push(msgStmt);\n\n    this.translations.set(key, variable);\n    return variable;\n  }\n\n  getDefinition(type: any, kind: DefinitionKind, ctx: OutputContext, forceShared: boolean = false):\n      o.Expression {\n    const definitions = this.definitionsOf(kind);\n    let fixup = definitions.get(type);\n    let newValue = false;\n    if (!fixup) {\n      const property = this.propertyNameOf(kind);\n      fixup = new FixupExpression(ctx.importExpr(type).prop(property));\n      definitions.set(type, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(fixup.resolved).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(o.variable(name));\n    }\n    return fixup;\n  }\n\n  getLiteralFactory(literal: o.LiteralArrayExpr|o.LiteralMapExpr):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    // Create a pure function that builds an array of a mix of constant  and variable expressions\n    if (literal instanceof o.LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : o.literal(null));\n      const key = this.keyOf(o.literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, entries => o.literalArr(entries));\n    } else {\n      const expressionForKey = o.literalMap(\n          literal.entries.map(e => ({\n                                key: e.key,\n                                value: e.value.isConstant() ? e.value : o.literal(null),\n                                quoted: e.quoted\n                              })));\n      const key = this.keyOf(expressionForKey);\n      return this._getLiteralFactory(\n          key, literal.entries.map(e => e.value),\n          entries => o.literalMap(entries.map((value, index) => ({\n                                                key: literal.entries[index].key,\n                                                value,\n                                                quoted: literal.entries[index].quoted\n                                              }))));\n    }\n  }\n\n  private _getLiteralFactory(\n      key: string, values: o.Expression[], resultMap: (parameters: o.Expression[]) => o.Expression):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter((e => !e.isConstant()));\n    if (!literalFactory) {\n      const resultExpressions = values.map(\n          (e, index) => e.isConstant() ? this.getConstLiteral(e, true) : o.variable(`a${index}`));\n      const parameters =\n          resultExpressions.filter(isVariable).map(e => new o.FnParam(e.name !, o.DYNAMIC_TYPE));\n      const pureFunctionDeclaration =\n          o.fn(parameters, [new o.ReturnStatement(resultMap(resultExpressions))], o.INFERRED_TYPE);\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(pureFunctionDeclaration).toDeclStmt(o.INFERRED_TYPE, [\n            o.StmtModifier.Final\n          ]));\n      literalFactory = o.variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {literalFactory, literalFactoryArguments};\n  }\n\n  /**\n   * Produce a unique name.\n   *\n   * The name might be unique among different prefixes if any of the prefixes end in\n   * a digit so the prefix should be a constant string (not based on user input) and\n   * must not end in a digit.\n   */\n  uniqueName(prefix: string): string { return `${prefix}${this.nextNameIndex++}`; }\n\n  private definitionsOf(kind: DefinitionKind): Map<any, FixupExpression> {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return this.componentDefinitions;\n      case DefinitionKind.Directive:\n        return this.directiveDefinitions;\n      case DefinitionKind.Injector:\n        return this.injectorDefinitions;\n      case DefinitionKind.Pipe:\n        return this.pipeDefinitions;\n    }\n    error(`Unknown definition kind ${kind}`);\n    return this.componentDefinitions;\n  }\n\n  public propertyNameOf(kind: DefinitionKind): string {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return 'ngComponentDef';\n      case DefinitionKind.Directive:\n        return 'ngDirectiveDef';\n      case DefinitionKind.Injector:\n        return 'ngInjectorDef';\n      case DefinitionKind.Pipe:\n        return 'ngPipeDef';\n    }\n    error(`Unknown definition kind ${kind}`);\n    return '<unknown>';\n  }\n\n  private freshName(): string { return this.uniqueName(CONSTANT_PREFIX); }\n\n  private freshTranslationName(): string {\n    return this.uniqueName(TRANSLATION_PREFIX).toUpperCase();\n  }\n\n  private keyOf(expression: o.Expression) {\n    return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n  }\n}\n\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\nclass KeyVisitor implements o.ExpressionVisitor {\n  visitLiteralExpr(ast: o.LiteralExpr): string {\n    return `${typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value}`;\n  }\n\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: object): string {\n    return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;\n  }\n\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: object): string {\n    const mapKey = (entry: o.LiteralMapEntry) => {\n      const quote = entry.quoted ? '\"' : '';\n      return `${quote}${entry.key}${quote}`;\n    };\n    const mapEntry = (entry: o.LiteralMapEntry) =>\n        `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;\n    return `{${ast.entries.map(mapEntry).join(',')}`;\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr): string {\n    return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :\n                                  `EX:${ast.value.runtime.name}`;\n  }\n\n  visitReadVarExpr(node: o.ReadVarExpr) { return `VAR:${node.name}`; }\n\n  visitTypeofExpr(node: o.TypeofExpr, context: any): string {\n    return `TYPEOF:${node.expr.visitExpression(this, context)}`;\n  }\n\n  visitWrappedNodeExpr = invalid;\n  visitWriteVarExpr = invalid;\n  visitWriteKeyExpr = invalid;\n  visitWritePropExpr = invalid;\n  visitInvokeMethodExpr = invalid;\n  visitInvokeFunctionExpr = invalid;\n  visitInstantiateExpr = invalid;\n  visitConditionalExpr = invalid;\n  visitNotExpr = invalid;\n  visitAssertNotNullExpr = invalid;\n  visitCastExpr = invalid;\n  visitFunctionExpr = invalid;\n  visitBinaryOperatorExpr = invalid;\n  visitReadPropExpr = invalid;\n  visitReadKeyExpr = invalid;\n  visitCommaExpr = invalid;\n}\n\nfunction invalid<T>(arg: o.Expression | o.Statement): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nfunction isVariable(e: o.Expression): e is o.ReadVarExpr {\n  return e instanceof o.ReadVarExpr;\n}\n\n// Converts i18n meta informations for a message (description, meaning) to a JsDoc statement\n// formatted as expected by the Closure compiler.\nfunction i18nMetaToDocStmt(meta: {description?: string, id?: string, meaning?: string}):\n    o.JSDocCommentStmt|null {\n  const tags: o.JSDocTag[] = [];\n\n  if (meta.description) {\n    tags.push({tagName: o.JSDocTagName.Desc, text: meta.description});\n  }\n\n  if (meta.meaning) {\n    tags.push({tagName: o.JSDocTagName.Meaning, text: meta.meaning});\n  }\n\n  return tags.length == 0 ? null : new o.JSDocCommentStmt(tags);\n}\n"]}