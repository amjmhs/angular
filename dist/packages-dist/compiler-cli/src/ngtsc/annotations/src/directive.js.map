{"version":3,"file":"directive.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/directive.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool, Expression, R3DirectiveMetadata, R3QueryMetadata, WrappedNodeExpr, compileDirectiveFromMetadata, makeBindingParser, parseHostBindings} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ClassMember, ClassMemberKind, Decorator, Import, ReflectionHost} from '../../host';\nimport {Reference, filterToMembersWithDecorator, reflectObjectLiteral, staticallyResolve} from '../../metadata';\nimport {AnalysisOutput, CompileResult, DecoratorHandler} from '../../transform';\n\nimport {SelectorScopeRegistry} from './selector_scope';\nimport {getConstructorDependencies, isAngularCore, unwrapExpression} from './util';\n\nconst EMPTY_OBJECT: {[key: string]: string} = {};\n\nexport class DirectiveDecoratorHandler implements DecoratorHandler<R3DirectiveMetadata> {\n  constructor(\n      private checker: ts.TypeChecker, private reflector: ReflectionHost,\n      private scopeRegistry: SelectorScopeRegistry, private isCore: boolean) {}\n\n  detect(decorators: Decorator[]): Decorator|undefined {\n    return decorators.find(\n        decorator => decorator.name === 'Directive' && (this.isCore || isAngularCore(decorator)));\n  }\n\n  analyze(node: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<R3DirectiveMetadata> {\n    const directiveResult =\n        extractDirectiveMetadata(node, decorator, this.checker, this.reflector, this.isCore);\n    const analysis = directiveResult && directiveResult.metadata;\n\n    // If the directive has a selector, it should be registered with the `SelectorScopeRegistry` so\n    // when this directive appears in an `@NgModule` scope, its selector can be determined.\n    if (analysis && analysis.selector !== null) {\n      this.scopeRegistry.registerSelector(node, analysis.selector);\n    }\n\n    return {analysis};\n  }\n\n  compile(node: ts.ClassDeclaration, analysis: R3DirectiveMetadata): CompileResult {\n    const pool = new ConstantPool();\n    const res = compileDirectiveFromMetadata(analysis, pool, makeBindingParser());\n    return {\n      name: 'ngDirectiveDef',\n      initializer: res.expression,\n      statements: pool.statements,\n      type: res.type,\n    };\n  }\n}\n\n/**\n * Helper function to extract metadata from a `Directive` or `Component`.\n */\nexport function extractDirectiveMetadata(\n    clazz: ts.ClassDeclaration, decorator: Decorator, checker: ts.TypeChecker,\n    reflector: ReflectionHost, isCore: boolean): {\n  decorator: Map<string, ts.Expression>,\n  metadata: R3DirectiveMetadata,\n  decoratedElements: ClassMember[],\n}|undefined {\n  if (decorator.args === null || decorator.args.length !== 1) {\n    throw new Error(`Incorrect number of arguments to @${decorator.name} decorator`);\n  }\n  const meta = unwrapExpression(decorator.args[0]);\n  if (!ts.isObjectLiteralExpression(meta)) {\n    throw new Error(`Decorator argument must be literal.`);\n  }\n  const directive = reflectObjectLiteral(meta);\n\n  if (directive.has('jit')) {\n    // The only allowed value is true, so there's no need to expand further.\n    return undefined;\n  }\n\n  const members = reflector.getMembersOfClass(clazz);\n\n  // Precompute a list of ts.ClassElements that have decorators. This includes things like @Input,\n  // @Output, @HostBinding, etc.\n  const decoratedElements =\n      members.filter(member => !member.isStatic && member.decorators !== null);\n\n  const coreModule = isCore ? undefined : '@angular/core';\n\n  // Construct the map of inputs both from the @Directive/@Component\n  // decorator, and the decorated\n  // fields.\n  const inputsFromMeta = parseFieldToPropertyMapping(directive, 'inputs', reflector, checker);\n  const inputsFromFields = parseDecoratedFields(\n      filterToMembersWithDecorator(decoratedElements, 'Input', coreModule), reflector, checker);\n\n  // And outputs.\n  const outputsFromMeta = parseFieldToPropertyMapping(directive, 'outputs', reflector, checker);\n  const outputsFromFields = parseDecoratedFields(\n      filterToMembersWithDecorator(decoratedElements, 'Output', coreModule), reflector, checker);\n  // Construct the list of queries.\n  const contentChildFromFields = queriesFromFields(\n      filterToMembersWithDecorator(decoratedElements, 'ContentChild', coreModule), reflector,\n      checker);\n  const contentChildrenFromFields = queriesFromFields(\n      filterToMembersWithDecorator(decoratedElements, 'ContentChildren', coreModule), reflector,\n      checker);\n\n  const queries = [...contentChildFromFields, ...contentChildrenFromFields];\n\n  if (directive.has('queries')) {\n    const queriesFromDecorator =\n        extractQueriesFromDecorator(directive.get('queries') !, reflector, checker, isCore);\n    queries.push(...queriesFromDecorator.content);\n  }\n\n  // Parse the selector.\n  let selector = '';\n  if (directive.has('selector')) {\n    const resolved = staticallyResolve(directive.get('selector') !, reflector, checker);\n    if (typeof resolved !== 'string') {\n      throw new Error(`Selector must be a string`);\n    }\n    selector = resolved;\n  }\n\n  const host = extractHostBindings(directive, decoratedElements, reflector, checker, coreModule);\n\n  // Determine if `ngOnChanges` is a lifecycle hook defined on the component.\n  const usesOnChanges = members.some(\n      member => !member.isStatic && member.kind === ClassMemberKind.Method &&\n          member.name === 'ngOnChanges');\n\n  // Detect if the component inherits from another class\n  const usesInheritance = clazz.heritageClauses !== undefined &&\n      clazz.heritageClauses.some(hc => hc.token === ts.SyntaxKind.ExtendsKeyword);\n  const metadata: R3DirectiveMetadata = {\n    name: clazz.name !.text,\n    deps: getConstructorDependencies(clazz, reflector, isCore), host,\n    lifecycle: {\n        usesOnChanges,\n    },\n    inputs: {...inputsFromMeta, ...inputsFromFields},\n    outputs: {...outputsFromMeta, ...outputsFromFields}, queries, selector,\n    type: new WrappedNodeExpr(clazz.name !),\n    typeArgumentCount: (clazz.typeParameters || []).length,\n    typeSourceSpan: null !, usesInheritance,\n  };\n  return {decoratedElements, decorator: directive, metadata};\n}\n\nexport function extractQueryMetadata(\n    name: string, args: ReadonlyArray<ts.Expression>, propertyName: string,\n    reflector: ReflectionHost, checker: ts.TypeChecker): R3QueryMetadata {\n  if (args.length === 0) {\n    throw new Error(`@${name} must have arguments`);\n  }\n  const first = name === 'ViewChild' || name === 'ContentChild';\n  const arg = staticallyResolve(args[0], reflector, checker);\n\n  // Extract the predicate\n  let predicate: Expression|string[]|null = null;\n  if (arg instanceof Reference) {\n    predicate = new WrappedNodeExpr(args[0]);\n  } else if (typeof arg === 'string') {\n    predicate = [arg];\n  } else if (isStringArrayOrDie(arg, '@' + name)) {\n    predicate = arg as string[];\n  } else {\n    throw new Error(`@${name} predicate cannot be interpreted`);\n  }\n\n  // Extract the read and descendants options.\n  let read: Expression|null = null;\n  // The default value for descendants is true for every decorator except @ContentChildren.\n  let descendants: boolean = name !== 'ContentChildren';\n  if (args.length === 2) {\n    const optionsExpr = unwrapExpression(args[1]);\n    if (!ts.isObjectLiteralExpression(optionsExpr)) {\n      throw new Error(`@${name} options must be an object literal`);\n    }\n    const options = reflectObjectLiteral(optionsExpr);\n    if (options.has('read')) {\n      read = new WrappedNodeExpr(options.get('read') !);\n    }\n\n    if (options.has('descendants')) {\n      const descendantsValue = staticallyResolve(options.get('descendants') !, reflector, checker);\n      if (typeof descendantsValue !== 'boolean') {\n        throw new Error(`@${name} options.descendants must be a boolean`);\n      }\n      descendants = descendantsValue;\n    }\n  } else if (args.length > 2) {\n    // Too many arguments.\n    throw new Error(`@${name} has too many arguments`);\n  }\n\n  return {\n      propertyName, predicate, first, descendants, read,\n  };\n}\n\nexport function extractQueriesFromDecorator(\n    queryData: ts.Expression, reflector: ReflectionHost, checker: ts.TypeChecker,\n    isCore: boolean): {\n  content: R3QueryMetadata[],\n  view: R3QueryMetadata[],\n} {\n  const content: R3QueryMetadata[] = [], view: R3QueryMetadata[] = [];\n  const expr = unwrapExpression(queryData);\n  if (!ts.isObjectLiteralExpression(queryData)) {\n    throw new Error(`queries metadata must be an object literal`);\n  }\n  reflectObjectLiteral(queryData).forEach((queryExpr, propertyName) => {\n    queryExpr = unwrapExpression(queryExpr);\n    if (!ts.isNewExpression(queryExpr) || !ts.isIdentifier(queryExpr.expression)) {\n      throw new Error(`query metadata must be an instance of a query type`);\n    }\n    const type = reflector.getImportOfIdentifier(queryExpr.expression);\n    if (type === null || (!isCore && type.from !== '@angular/core') ||\n        !QUERY_TYPES.has(type.name)) {\n      throw new Error(`query metadata must be an instance of a query type`);\n    }\n\n    const query = extractQueryMetadata(\n        type.name, queryExpr.arguments || [], propertyName, reflector, checker);\n    if (type.name.startsWith('Content')) {\n      content.push(query);\n    } else {\n      view.push(query);\n    }\n  });\n  return {content, view};\n}\n\nfunction isStringArrayOrDie(value: any, name: string): value is string[] {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    if (typeof value[i] !== 'string') {\n      throw new Error(`Failed to resolve ${name}[${i}] to a string`);\n    }\n  }\n  return true;\n}\n\n/**\n * Interpret property mapping fields on the decorator (e.g. inputs or outputs) and return the\n * correctly shaped metadata object.\n */\nfunction parseFieldToPropertyMapping(\n    directive: Map<string, ts.Expression>, field: string, reflector: ReflectionHost,\n    checker: ts.TypeChecker): {[field: string]: string} {\n  if (!directive.has(field)) {\n    return EMPTY_OBJECT;\n  }\n\n  // Resolve the field of interest from the directive metadata to a string[].\n  const metaValues = staticallyResolve(directive.get(field) !, reflector, checker);\n  if (!isStringArrayOrDie(metaValues, field)) {\n    throw new Error(`Failed to resolve @Directive.${field}`);\n  }\n\n  return metaValues.reduce(\n      (results, value) => {\n        // Either the value is 'field' or 'field: property'. In the first case, `property` will\n        // be undefined, in which case the field name should also be used as the property name.\n        const [field, property] = value.split(':', 2).map(str => str.trim());\n        results[field] = property || field;\n        return results;\n      },\n      {} as{[field: string]: string});\n}\n\n/**\n * Parse property decorators (e.g. `Input` or `Output`) and return the correctly shaped metadata\n * object.\n */\nfunction parseDecoratedFields(\n    fields: {member: ClassMember, decorators: Decorator[]}[], reflector: ReflectionHost,\n    checker: ts.TypeChecker): {[field: string]: string} {\n  return fields.reduce(\n      (results, field) => {\n        const fieldName = field.member.name;\n        field.decorators.forEach(decorator => {\n          // The decorator either doesn't have an argument (@Input()) in which case the property\n          // name is used, or it has one argument (@Output('named')).\n          if (decorator.args == null || decorator.args.length === 0) {\n            results[fieldName] = fieldName;\n          } else if (decorator.args.length === 1) {\n            const property = staticallyResolve(decorator.args[0], reflector, checker);\n            if (typeof property !== 'string') {\n              throw new Error(`Decorator argument must resolve to a string`);\n            }\n            results[fieldName] = property;\n          } else {\n            // Too many arguments.\n            throw new Error(\n                `Decorator must have 0 or 1 arguments, got ${decorator.args.length} argument(s)`);\n          }\n        });\n        return results;\n      },\n      {} as{[field: string]: string});\n}\n\nexport function queriesFromFields(\n    fields: {member: ClassMember, decorators: Decorator[]}[], reflector: ReflectionHost,\n    checker: ts.TypeChecker): R3QueryMetadata[] {\n  return fields.map(({member, decorators}) => {\n    if (decorators.length !== 1) {\n      throw new Error(`Cannot have multiple query decorators on the same class member`);\n    } else if (!isPropertyTypeMember(member)) {\n      throw new Error(`Query decorator must go on a property-type member`);\n    }\n    const decorator = decorators[0];\n    return extractQueryMetadata(\n        decorator.name, decorator.args || [], member.name, reflector, checker);\n  });\n}\n\nfunction isPropertyTypeMember(member: ClassMember): boolean {\n  return member.kind === ClassMemberKind.Getter || member.kind === ClassMemberKind.Setter ||\n      member.kind === ClassMemberKind.Property;\n}\n\ntype StringMap = {\n  [key: string]: string\n};\n\nfunction extractHostBindings(\n    metadata: Map<string, ts.Expression>, members: ClassMember[], reflector: ReflectionHost,\n    checker: ts.TypeChecker, coreModule: string | undefined): {\n  attributes: StringMap,\n  listeners: StringMap,\n  properties: StringMap,\n} {\n  let hostMetadata: StringMap = {};\n  if (metadata.has('host')) {\n    const hostMetaMap = staticallyResolve(metadata.get('host') !, reflector, checker);\n    if (!(hostMetaMap instanceof Map)) {\n      throw new Error(`Decorator host metadata must be an object`);\n    }\n    hostMetaMap.forEach((value, key) => {\n      if (typeof value !== 'string' || typeof key !== 'string') {\n        throw new Error(`Decorator host metadata must be a string -> string object, got ${value}`);\n      }\n      hostMetadata[key] = value;\n    });\n  }\n\n  const {attributes, listeners, properties, animations} = parseHostBindings(hostMetadata);\n\n  filterToMembersWithDecorator(members, 'HostBinding', coreModule)\n      .forEach(({member, decorators}) => {\n        decorators.forEach(decorator => {\n          let hostPropertyName: string = member.name;\n          if (decorator.args !== null && decorator.args.length > 0) {\n            if (decorator.args.length !== 1) {\n              throw new Error(`@HostBinding() can have at most one argument`);\n            }\n\n            const resolved = staticallyResolve(decorator.args[0], reflector, checker);\n            if (typeof resolved !== 'string') {\n              throw new Error(`@HostBinding()'s argument must be a string`);\n            }\n\n            hostPropertyName = resolved;\n          }\n\n          properties[hostPropertyName] = member.name;\n        });\n      });\n\n  filterToMembersWithDecorator(members, 'HostListener', coreModule)\n      .forEach(({member, decorators}) => {\n        decorators.forEach(decorator => {\n          let eventName: string = member.name;\n          let args: string[] = [];\n          if (decorator.args !== null && decorator.args.length > 0) {\n            if (decorator.args.length > 2) {\n              throw new Error(`@HostListener() can have at most two arguments`);\n            }\n\n            const resolved = staticallyResolve(decorator.args[0], reflector, checker);\n            if (typeof resolved !== 'string') {\n              throw new Error(`@HostListener()'s event name argument must be a string`);\n            }\n\n            eventName = resolved;\n\n            if (decorator.args.length === 2) {\n              const resolvedArgs = staticallyResolve(decorator.args[1], reflector, checker);\n              if (!isStringArrayOrDie(resolvedArgs, '@HostListener.args')) {\n                throw new Error(`@HostListener second argument must be a string array`);\n              }\n              args = resolvedArgs;\n            }\n          }\n\n          listeners[eventName] = `${member.name}(${args.join(',')})`;\n        });\n      });\n  return {attributes, properties, listeners};\n}\n\nconst QUERY_TYPES = new Set([\n  'ContentChild',\n  'ContentChildren',\n  'ViewChild',\n  'ViewChildren',\n]);\n"]}