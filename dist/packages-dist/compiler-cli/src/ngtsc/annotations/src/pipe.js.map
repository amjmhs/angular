{"version":3,"file":"pipe.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/pipe.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {LiteralExpr, R3PipeMetadata, WrappedNodeExpr, compilePipeFromMetadata} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {Decorator, ReflectionHost} from '../../host';\nimport {reflectObjectLiteral, staticallyResolve} from '../../metadata';\nimport {AnalysisOutput, CompileResult, DecoratorHandler} from '../../transform';\n\nimport {SelectorScopeRegistry} from './selector_scope';\nimport {getConstructorDependencies, isAngularCore, unwrapExpression} from './util';\n\nexport class PipeDecoratorHandler implements DecoratorHandler<R3PipeMetadata> {\n  constructor(\n      private checker: ts.TypeChecker, private reflector: ReflectionHost,\n      private scopeRegistry: SelectorScopeRegistry, private isCore: boolean) {}\n\n  detect(decorator: Decorator[]): Decorator|undefined {\n    return decorator.find(\n        decorator => decorator.name === 'Pipe' && (this.isCore || isAngularCore(decorator)));\n  }\n\n  analyze(clazz: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<R3PipeMetadata> {\n    if (clazz.name === undefined) {\n      throw new Error(`@Pipes must have names`);\n    }\n    const name = clazz.name.text;\n    const type = new WrappedNodeExpr(clazz.name);\n    if (decorator.args === null) {\n      throw new Error(`@Pipe must be called`);\n    }\n    const meta = unwrapExpression(decorator.args[0]);\n    if (!ts.isObjectLiteralExpression(meta)) {\n      throw new Error(`Decorator argument must be literal.`);\n    }\n    const pipe = reflectObjectLiteral(meta);\n\n    if (!pipe.has('name')) {\n      throw new Error(`@Pipe decorator is missing name field`);\n    }\n    const pipeName = staticallyResolve(pipe.get('name') !, this.reflector, this.checker);\n    if (typeof pipeName !== 'string') {\n      throw new Error(`@Pipe.name must be a string`);\n    }\n    this.scopeRegistry.registerPipe(clazz, pipeName);\n\n    let pure = true;\n    if (pipe.has('pure')) {\n      const pureValue = staticallyResolve(pipe.get('pure') !, this.reflector, this.checker);\n      if (typeof pureValue !== 'boolean') {\n        throw new Error(`@Pipe.pure must be a boolean`);\n      }\n      pure = pureValue;\n    }\n\n    return {\n      analysis: {\n        name,\n        type,\n        pipeName,\n        deps: getConstructorDependencies(clazz, this.reflector, this.isCore), pure,\n      }\n    };\n  }\n\n  compile(node: ts.ClassDeclaration, analysis: R3PipeMetadata): CompileResult {\n    const res = compilePipeFromMetadata(analysis);\n    return {\n      name: 'ngPipeDef',\n      initializer: res.expression,\n      statements: [],\n      type: res.type,\n    };\n  }\n}\n"]}