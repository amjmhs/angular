{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, R3DependencyMetadata, R3ResolvedDependencyType, WrappedNodeExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {Decorator, ReflectionHost} from '../../host';\nimport {Reference} from '../../metadata';\n\nexport function getConstructorDependencies(\n    clazz: ts.ClassDeclaration, reflector: ReflectionHost,\n    isCore: boolean): R3DependencyMetadata[] {\n  const useType: R3DependencyMetadata[] = [];\n  const ctorParams = reflector.getConstructorParameters(clazz) || [];\n  ctorParams.forEach((param, idx) => {\n    let tokenExpr = param.type;\n    let optional = false, self = false, skipSelf = false, host = false;\n    let resolved = R3ResolvedDependencyType.Token;\n    (param.decorators || []).filter(dec => isCore || isAngularCore(dec)).forEach(dec => {\n      if (dec.name === 'Inject') {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new Error(`Unexpected number of arguments to @Inject().`);\n        }\n        tokenExpr = dec.args[0];\n      } else if (dec.name === 'Optional') {\n        optional = true;\n      } else if (dec.name === 'SkipSelf') {\n        skipSelf = true;\n      } else if (dec.name === 'Self') {\n        self = true;\n      } else if (dec.name === 'Host') {\n        host = true;\n      } else if (dec.name === 'Attribute') {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new Error(`Unexpected number of arguments to @Attribute().`);\n        }\n        tokenExpr = dec.args[0];\n        resolved = R3ResolvedDependencyType.Attribute;\n      } else {\n        throw new Error(`Unexpected decorator ${dec.name} on parameter.`);\n      }\n    });\n    if (tokenExpr === null) {\n      throw new Error(\n          `No suitable token for parameter ${param.name || idx} of class ${clazz.name!.text}`);\n    }\n    if (ts.isIdentifier(tokenExpr)) {\n      const importedSymbol = reflector.getImportOfIdentifier(tokenExpr);\n      if (importedSymbol !== null && importedSymbol.from === '@angular/core') {\n        switch (importedSymbol.name) {\n          case 'ChangeDetectorRef':\n            resolved = R3ResolvedDependencyType.ChangeDetectorRef;\n            break;\n          case 'ElementRef':\n            resolved = R3ResolvedDependencyType.ElementRef;\n            break;\n          case 'Injector':\n            resolved = R3ResolvedDependencyType.Injector;\n            break;\n          case 'TemplateRef':\n            resolved = R3ResolvedDependencyType.TemplateRef;\n            break;\n          case 'ViewContainerRef':\n            resolved = R3ResolvedDependencyType.ViewContainerRef;\n            break;\n          default:\n            // Leave as a Token or Attribute.\n        }\n      }\n    }\n    const token = new WrappedNodeExpr(tokenExpr);\n    useType.push({token, optional, self, skipSelf, host, resolved});\n  });\n  return useType;\n}\n\nexport function referenceToExpression(ref: Reference, context: ts.SourceFile): Expression {\n  const exp = ref.toExpression(context);\n  if (exp === null) {\n    throw new Error(`Could not refer to ${ts.SyntaxKind[ref.node.kind]}`);\n  }\n  return exp;\n}\n\nexport function isAngularCore(decorator: Decorator): boolean {\n  return decorator.import !== null && decorator.import.from === '@angular/core';\n}\n\n/**\n * Unwrap a `ts.Expression`, removing outer type-casts or parentheses until the expression is in its\n * lowest level form.\n *\n * For example, the expression \"(foo as Type)\" unwraps to \"foo\".\n */\nexport function unwrapExpression(node: ts.Expression): ts.Expression {\n  while (ts.isAsExpression(node) || ts.isParenthesizedExpression(node)) {\n    node = node.expression;\n  }\n  return node;\n}\n"]}