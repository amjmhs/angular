{"version":3,"file":"selector_scope.js","sourceRoot":"","sources":["../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/selector_scope.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, ExternalExpr, ExternalReference} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ReflectionHost} from '../../host';\nimport {AbsoluteReference, Reference, reflectTypeEntityToDeclaration} from '../../metadata';\nimport {reflectIdentifierOfDeclaration, reflectNameOfDeclaration} from '../../metadata/src/reflector';\n\nimport {referenceToExpression} from './util';\n\n\n\n/**\n * Metadata extracted for a given NgModule that can be used to compute selector scopes.\n */\nexport interface ModuleData {\n  declarations: Reference[];\n  imports: Reference[];\n  exports: Reference[];\n}\n\n/**\n * Transitively expanded maps of directives and pipes visible to a component being compiled in the\n * context of some module.\n */\nexport interface CompilationScope<T> {\n  directives: Map<string, T>;\n  pipes: Map<string, T>;\n}\n\n/**\n * Both transitively expanded scopes for a given NgModule.\n */\ninterface SelectorScopes {\n  /**\n   * Set of components, directives, and pipes visible to all components being compiled in the\n   * context of some module.\n   */\n  compilation: Reference[];\n\n  /**\n   * Set of components, directives, and pipes added to the compilation scope of any module importing\n   * some module.\n   */\n  exported: Reference[];\n}\n\n/**\n * Registry which records and correlates static analysis information of Angular types.\n *\n * Once a compilation unit's information is fed into the SelectorScopeRegistry, it can be asked to\n * produce transitive `CompilationScope`s for components.\n */\nexport class SelectorScopeRegistry {\n  /**\n   *  Map of modules declared in the current compilation unit to their (local) metadata.\n   */\n  private _moduleToData = new Map<ts.Declaration, ModuleData>();\n\n  /**\n   * Map of modules to their cached `CompilationScope`s.\n   */\n  private _compilationScopeCache = new Map<ts.Declaration, CompilationScope<Reference>>();\n\n  /**\n   * Map of components/directives to their selector.\n   */\n  private _directiveToSelector = new Map<ts.Declaration, string>();\n\n  /**\n   * Map of pipes to their name.\n   */\n  private _pipeToName = new Map<ts.Declaration, string>();\n\n  /**\n   * Map of components/directives/pipes to their module.\n   */\n  private _declararedTypeToModule = new Map<ts.Declaration, ts.Declaration>();\n\n  constructor(private checker: ts.TypeChecker, private reflector: ReflectionHost) {}\n\n  /**\n   * Register a module's metadata with the registry.\n   */\n  registerModule(node: ts.Declaration, data: ModuleData): void {\n    node = ts.getOriginalNode(node) as ts.Declaration;\n\n    if (this._moduleToData.has(node)) {\n      throw new Error(`Module already registered: ${reflectNameOfDeclaration(node)}`);\n    }\n    this._moduleToData.set(node, data);\n\n    // Register all of the module's declarations in the context map as belonging to this module.\n    data.declarations.forEach(decl => {\n      this._declararedTypeToModule.set(ts.getOriginalNode(decl.node) as ts.Declaration, node);\n    });\n  }\n\n  /**\n   * Register the selector of a component or directive with the registry.\n   */\n  registerSelector(node: ts.Declaration, selector: string): void {\n    node = ts.getOriginalNode(node) as ts.Declaration;\n\n    if (this._directiveToSelector.has(node)) {\n      throw new Error(`Selector already registered: ${reflectNameOfDeclaration(node)} ${selector}`);\n    }\n    this._directiveToSelector.set(node, selector);\n  }\n\n  /**\n   * Register the name of a pipe with the registry.\n   */\n  registerPipe(node: ts.Declaration, name: string): void {\n    node = ts.getOriginalNode(node) as ts.Declaration;\n\n    this._pipeToName.set(node, name);\n  }\n\n  /**\n   * Produce the compilation scope of a component, which is determined by the module that declares\n   * it.\n   */\n  lookupCompilationScope(node: ts.Declaration): CompilationScope<Expression>|null {\n    node = ts.getOriginalNode(node) as ts.Declaration;\n\n    // If the component has no associated module, then it has no compilation scope.\n    if (!this._declararedTypeToModule.has(node)) {\n      return null;\n    }\n\n    const module = this._declararedTypeToModule.get(node) !;\n\n    // Compilation scope computation is somewhat expensive, so it's cached. Check the cache for\n    // the module.\n    if (this._compilationScopeCache.has(module)) {\n      // The compilation scope was cached.\n      const scope = this._compilationScopeCache.get(module) !;\n\n      // The scope as cached is in terms of References, not Expressions. Converting between them\n      // requires knowledge of the context file (in this case, the component node's source file).\n      return convertScopeToExpressions(scope, node.getSourceFile());\n    }\n\n    // This is the first time the scope for this module is being computed.\n    const directives = new Map<string, Reference>();\n    const pipes = new Map<string, Reference>();\n\n    // Process the declaration scope of the module, and lookup the selector of every declared type.\n    // The initial value of ngModuleImportedFrom is 'null' which signifies that the NgModule\n    // was not imported from a .d.ts source.\n    this.lookupScopes(module !, /* ngModuleImportedFrom */ null).compilation.forEach(ref => {\n      const node = ts.getOriginalNode(ref.node) as ts.Declaration;\n\n      // Either the node represents a directive or a pipe. Look for both.\n      const selector = this.lookupDirectiveSelector(node);\n      // Only directives/components with selectors get added to the scope.\n      if (selector != null) {\n        directives.set(selector, ref);\n        return;\n      }\n\n      const name = this.lookupPipeName(node);\n      if (name != null) {\n        pipes.set(name, ref);\n      }\n    });\n\n    const scope: CompilationScope<Reference> = {directives, pipes};\n\n    // Many components may be compiled in the same scope, so cache it.\n    this._compilationScopeCache.set(node, scope);\n\n    // Convert References to Expressions in the context of the component's source file.\n    return convertScopeToExpressions(scope, node.getSourceFile());\n  }\n\n  /**\n   * Lookup `SelectorScopes` for a given module.\n   *\n   * This function assumes that if the given module was imported from an absolute path\n   * (`ngModuleImportedFrom`) then all of its declarations are exported at that same path, as well\n   * as imports and exports from other modules that are relatively imported.\n   */\n  private lookupScopes(node: ts.Declaration, ngModuleImportedFrom: string|null): SelectorScopes {\n    let data: ModuleData|null = null;\n\n    // Either this module was analyzed directly, or has a precompiled ngModuleDef.\n    if (this._moduleToData.has(node)) {\n      // The module was analyzed before, and thus its data is available.\n      data = this._moduleToData.get(node) !;\n    } else {\n      // The module wasn't analyzed before, and probably has a precompiled ngModuleDef with a type\n      // annotation that specifies the needed metadata.\n      if (ngModuleImportedFrom === null) {\n        // TODO(alxhub): handle hand-compiled ngModuleDef in the current Program.\n        throw new Error(`Need to read .d.ts module but ngModuleImportedFrom is unspecified`);\n      }\n      data = this._readMetadataFromCompiledClass(node, ngModuleImportedFrom);\n      // Note that data here could still be null, if the class didn't have a precompiled\n      // ngModuleDef.\n    }\n\n    if (data === null) {\n      throw new Error(`Module not registered: ${reflectNameOfDeclaration(node)}`);\n    }\n\n    return {\n      compilation: [\n        ...data.declarations,\n        // Expand imports to the exported scope of those imports.\n        ...flatten(data.imports.map(\n            ref =>\n                this.lookupScopes(ref.node as ts.Declaration, absoluteModuleName(ref)).exported)),\n        // And include the compilation scope of exported modules.\n        ...flatten(\n            data.exports.filter(ref => this._moduleToData.has(ref.node as ts.Declaration))\n                .map(\n                    ref => this.lookupScopes(ref.node as ts.Declaration, absoluteModuleName(ref))\n                               .exported))\n      ],\n      exported: flatten(data.exports.map(ref => {\n        if (this._moduleToData.has(ref.node as ts.Declaration)) {\n          return this.lookupScopes(ref.node as ts.Declaration, absoluteModuleName(ref)).exported;\n        } else {\n          return [ref];\n        }\n      })),\n    };\n  }\n\n  /**\n   * Lookup the selector of a component or directive class.\n   *\n   * Potentially this class is declared in a .d.ts file or otherwise has a manually created\n   * ngComponentDef/ngDirectiveDef. In this case, the type metadata of that definition is read\n   * to determine the selector.\n   */\n  private lookupDirectiveSelector(node: ts.Declaration): string|null {\n    if (this._directiveToSelector.has(node)) {\n      return this._directiveToSelector.get(node) !;\n    } else {\n      return this._readSelectorFromCompiledClass(node);\n    }\n  }\n\n  private lookupPipeName(node: ts.Declaration): string|null {\n    if (this._pipeToName.has(node)) {\n      return this._pipeToName.get(node) !;\n    } else {\n      return this._readNameFromCompiledClass(node);\n    }\n  }\n\n  /**\n   * Read the metadata from a class that has already been compiled somehow (either it's in a .d.ts\n   * file, or in a .ts file with a handwritten definition).\n   *\n   * @param clazz the class of interest\n   * @param ngModuleImportedFrom module specifier of the import path to assume for all declarations\n   * stemming from this module.\n   */\n  private _readMetadataFromCompiledClass(clazz: ts.Declaration, ngModuleImportedFrom: string):\n      ModuleData|null {\n    // This operation is explicitly not memoized, as it depends on `ngModuleImportedFrom`.\n    // TODO(alxhub): investigate caching of .d.ts module metadata.\n    const ngModuleDef = this.reflector.getMembersOfClass(clazz).find(\n        member => member.name === 'ngModuleDef' && member.isStatic);\n    if (ngModuleDef === undefined) {\n      return null;\n    } else if (\n        // Validate that the shape of the ngModuleDef type is correct.\n        ngModuleDef.type === null || !ts.isTypeReferenceNode(ngModuleDef.type) ||\n        ngModuleDef.type.typeArguments === undefined ||\n        ngModuleDef.type.typeArguments.length !== 4) {\n      return null;\n    }\n\n    // Read the ModuleData out of the type arguments.\n    const [_, declarationMetadata, importMetadata, exportMetadata] = ngModuleDef.type.typeArguments;\n    return {\n      declarations: this._extractReferencesFromType(declarationMetadata, ngModuleImportedFrom),\n      exports: this._extractReferencesFromType(exportMetadata, ngModuleImportedFrom),\n      imports: this._extractReferencesFromType(importMetadata, ngModuleImportedFrom),\n    };\n  }\n\n  /**\n   * Get the selector from type metadata for a class with a precompiled ngComponentDef or\n   * ngDirectiveDef.\n   */\n  private _readSelectorFromCompiledClass(clazz: ts.Declaration): string|null {\n    const def = this.reflector.getMembersOfClass(clazz).find(\n        field =>\n            field.isStatic && (field.name === 'ngComponentDef' || field.name === 'ngDirectiveDef'));\n    if (def === undefined) {\n      // No definition could be found.\n      return null;\n    } else if (\n        def.type === null || !ts.isTypeReferenceNode(def.type) ||\n        def.type.typeArguments === undefined || def.type.typeArguments.length !== 2) {\n      // The type metadata was the wrong shape.\n      return null;\n    }\n    const type = def.type.typeArguments[1];\n    if (!ts.isLiteralTypeNode(type) || !ts.isStringLiteral(type.literal)) {\n      // The type metadata was the wrong type.\n      return null;\n    }\n    return type.literal.text;\n  }\n\n  /**\n   * Get the selector from type metadata for a class with a precompiled ngComponentDef or\n   * ngDirectiveDef.\n   */\n  private _readNameFromCompiledClass(clazz: ts.Declaration): string|null {\n    const def = this.reflector.getMembersOfClass(clazz).find(\n        field => field.isStatic && field.name === 'ngPipeDef');\n    if (def === undefined) {\n      // No definition could be found.\n      return null;\n    } else if (\n        def.type === null || !ts.isTypeReferenceNode(def.type) ||\n        def.type.typeArguments === undefined || def.type.typeArguments.length !== 2) {\n      // The type metadata was the wrong shape.\n      return null;\n    }\n    const type = def.type.typeArguments[1];\n    if (!ts.isLiteralTypeNode(type) || !ts.isStringLiteral(type.literal)) {\n      // The type metadata was the wrong type.\n      return null;\n    }\n    return type.literal.text;\n  }\n\n  /**\n   * Process a `TypeNode` which is a tuple of references to other types, and return `Reference`s to\n   * them.\n   *\n   * This operation assumes that these types should be imported from `ngModuleImportedFrom` unless\n   * they themselves were imported from another absolute path.\n   */\n  private _extractReferencesFromType(def: ts.TypeNode, ngModuleImportedFrom: string): Reference[] {\n    if (!ts.isTupleTypeNode(def)) {\n      return [];\n    }\n    return def.elementTypes.map(element => {\n      if (!ts.isTypeQueryNode(element)) {\n        throw new Error(`Expected TypeQueryNode`);\n      }\n      const type = element.exprName;\n      const {node, from} = reflectTypeEntityToDeclaration(type, this.checker);\n      const moduleName = (from !== null && !from.startsWith('.') ? from : ngModuleImportedFrom);\n      const clazz = node as ts.Declaration;\n      const id = reflectIdentifierOfDeclaration(clazz);\n      return new AbsoluteReference(node, id !, moduleName, id !.text);\n    });\n  }\n}\n\nfunction flatten<T>(array: T[][]): T[] {\n  return array.reduce((accum, subArray) => {\n    accum.push(...subArray);\n    return accum;\n  }, [] as T[]);\n}\n\nfunction absoluteModuleName(ref: Reference): string|null {\n  if (!(ref instanceof AbsoluteReference)) {\n    return null;\n  }\n  return ref.moduleName;\n}\n\nfunction convertReferenceMap(\n    map: Map<string, Reference>, context: ts.SourceFile): Map<string, Expression> {\n  return new Map<string, Expression>(Array.from(map.entries()).map(([selector, ref]): [\n    string, Expression\n  ] => [selector, referenceToExpression(ref, context)]));\n}\n\nfunction convertScopeToExpressions(\n    scope: CompilationScope<Reference>, context: ts.SourceFile): CompilationScope<Expression> {\n  const directives = convertReferenceMap(scope.directives, context);\n  const pipes = convertReferenceMap(scope.pipes, context);\n  return {directives, pipes};\n}\n"]}