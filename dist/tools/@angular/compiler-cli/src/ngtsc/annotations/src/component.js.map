{"version":3,"file":"component.js","sourceRoot":"","sources":["../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/component.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool, Expression, R3ComponentMetadata, R3DirectiveMetadata, WrappedNodeExpr, compileComponentFromMetadata, makeBindingParser, parseTemplate} from '@angular/compiler';\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nimport {Decorator, ReflectionHost} from '../../host';\nimport {filterToMembersWithDecorator, reflectObjectLiteral, staticallyResolve} from '../../metadata';\nimport {AnalysisOutput, CompileResult, DecoratorHandler} from '../../transform';\n\nimport {ResourceLoader} from './api';\nimport {extractDirectiveMetadata, extractQueriesFromDecorator, queriesFromFields} from './directive';\nimport {SelectorScopeRegistry} from './selector_scope';\nimport {isAngularCore, unwrapExpression} from './util';\n\nconst EMPTY_MAP = new Map<string, Expression>();\n\n/**\n * `DecoratorHandler` which handles the `@Component` annotation.\n */\nexport class ComponentDecoratorHandler implements DecoratorHandler<R3ComponentMetadata> {\n  constructor(\n      private checker: ts.TypeChecker, private reflector: ReflectionHost,\n      private scopeRegistry: SelectorScopeRegistry, private isCore: boolean,\n      private resourceLoader: ResourceLoader) {}\n\n  private literalCache = new Map<Decorator, ts.ObjectLiteralExpression>();\n\n\n  detect(decorators: Decorator[]): Decorator|undefined {\n    return decorators.find(\n        decorator => decorator.name === 'Component' && (this.isCore || isAngularCore(decorator)));\n  }\n\n  preanalyze(node: ts.ClassDeclaration, decorator: Decorator): Promise<void>|undefined {\n    const meta = this._resolveLiteral(decorator);\n    const component = reflectObjectLiteral(meta);\n\n    if (this.resourceLoader.preload !== undefined && component.has('templateUrl')) {\n      const templateUrl =\n          staticallyResolve(component.get('templateUrl') !, this.reflector, this.checker);\n      if (typeof templateUrl !== 'string') {\n        throw new Error(`templateUrl should be a string`);\n      }\n      const url = path.posix.resolve(path.dirname(node.getSourceFile().fileName), templateUrl);\n      return this.resourceLoader.preload(url);\n    }\n    return undefined;\n  }\n\n  analyze(node: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<R3ComponentMetadata> {\n    const meta = this._resolveLiteral(decorator);\n    this.literalCache.delete(decorator);\n\n    // @Component inherits @Directive, so begin by extracting the @Directive metadata and building\n    // on it.\n    const directiveResult =\n        extractDirectiveMetadata(node, decorator, this.checker, this.reflector, this.isCore);\n    if (directiveResult === undefined) {\n      // `extractDirectiveMetadata` returns undefined when the @Directive has `jit: true`. In this\n      // case, compilation of the decorator is skipped. Returning an empty object signifies\n      // that no analysis was produced.\n      return {};\n    }\n\n    // Next, read the `@Component`-specific fields.\n    const {decoratedElements, decorator: component, metadata} = directiveResult;\n\n    let templateStr: string|null = null;\n    if (component.has('templateUrl')) {\n      const templateUrl =\n          staticallyResolve(component.get('templateUrl') !, this.reflector, this.checker);\n      if (typeof templateUrl !== 'string') {\n        throw new Error(`templateUrl should be a string`);\n      }\n      const url = path.posix.resolve(path.dirname(node.getSourceFile().fileName), templateUrl);\n      templateStr = this.resourceLoader.load(url);\n    } else if (component.has('template')) {\n      const templateExpr = component.get('template') !;\n      const resolvedTemplate = staticallyResolve(templateExpr, this.reflector, this.checker);\n      if (typeof resolvedTemplate !== 'string') {\n        throw new Error(`Template must statically resolve to a string: ${node.name!.text}`);\n      }\n      templateStr = resolvedTemplate;\n    } else {\n      throw new Error(`Component has no template or templateUrl`);\n    }\n\n    let preserveWhitespaces: boolean = false;\n    if (component.has('preserveWhitespaces')) {\n      const value =\n          staticallyResolve(component.get('preserveWhitespaces') !, this.reflector, this.checker);\n      if (typeof value !== 'boolean') {\n        throw new Error(`preserveWhitespaces must resolve to a boolean if present`);\n      }\n      preserveWhitespaces = value;\n    }\n\n    const template = parseTemplate(\n        templateStr, `${node.getSourceFile().fileName}#${node.name!.text}/template.html`,\n        {preserveWhitespaces});\n    if (template.errors !== undefined) {\n      throw new Error(\n          `Errors parsing template: ${template.errors.map(e => e.toString()).join(', ')}`);\n    }\n\n    // If the component has a selector, it should be registered with the `SelectorScopeRegistry` so\n    // when this component appears in an `@NgModule` scope, its selector can be determined.\n    if (metadata.selector !== null) {\n      this.scopeRegistry.registerSelector(node, metadata.selector);\n    }\n\n    // Construct the list of view queries.\n    const coreModule = this.isCore ? undefined : '@angular/core';\n    const viewChildFromFields = queriesFromFields(\n        filterToMembersWithDecorator(decoratedElements, 'ViewChild', coreModule), this.reflector,\n        this.checker);\n    const viewChildrenFromFields = queriesFromFields(\n        filterToMembersWithDecorator(decoratedElements, 'ViewChildren', coreModule), this.reflector,\n        this.checker);\n    const viewQueries = [...viewChildFromFields, ...viewChildrenFromFields];\n\n    if (component.has('queries')) {\n      const queriesFromDecorator = extractQueriesFromDecorator(\n          component.get('queries') !, this.reflector, this.checker, this.isCore);\n      viewQueries.push(...queriesFromDecorator.view);\n    }\n\n    return {\n      analysis: {\n        ...metadata,\n        template,\n        viewQueries,\n\n        // These will be replaced during the compilation step, after all `NgModule`s have been\n        // analyzed and the full compilation scope for the component can be realized.\n        pipes: EMPTY_MAP,\n        directives: EMPTY_MAP,\n      }\n    };\n  }\n\n  compile(node: ts.ClassDeclaration, analysis: R3ComponentMetadata): CompileResult {\n    const pool = new ConstantPool();\n\n    // Check whether this component was registered with an NgModule. If so, it should be compiled\n    // under that module's compilation scope.\n    const scope = this.scopeRegistry.lookupCompilationScope(node);\n    if (scope !== null) {\n      // Replace the empty components and directives from the analyze() step with a fully expanded\n      // scope. This is possible now because during compile() the whole compilation unit has been\n      // fully analyzed.\n      analysis = {...analysis, ...scope};\n    }\n\n    const res = compileComponentFromMetadata(analysis, pool, makeBindingParser());\n    return {\n      name: 'ngComponentDef',\n      initializer: res.expression,\n      statements: pool.statements,\n      type: res.type,\n    };\n  }\n\n  private _resolveLiteral(decorator: Decorator): ts.ObjectLiteralExpression {\n    if (this.literalCache.has(decorator)) {\n      return this.literalCache.get(decorator) !;\n    }\n    if (decorator.args === null || decorator.args.length !== 1) {\n      throw new Error(`Incorrect number of arguments to @Component decorator`);\n    }\n    const meta = unwrapExpression(decorator.args[0]);\n\n    if (!ts.isObjectLiteralExpression(meta)) {\n      throw new Error(`Decorator argument must be literal.`);\n    }\n\n    this.literalCache.set(decorator, meta);\n    return meta;\n  }\n}\n"]}