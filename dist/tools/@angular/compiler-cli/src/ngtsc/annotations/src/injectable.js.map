{"version":3,"file":"injectable.js","sourceRoot":"","sources":["../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, LiteralExpr, R3DependencyMetadata, R3InjectableMetadata, R3ResolvedDependencyType, WrappedNodeExpr, compileInjectable as compileIvyInjectable} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {Decorator, ReflectionHost} from '../../host';\nimport {reflectObjectLiteral} from '../../metadata';\nimport {AnalysisOutput, CompileResult, DecoratorHandler} from '../../transform';\n\nimport {getConstructorDependencies, isAngularCore} from './util';\n\n\n/**\n * Adapts the `compileIvyInjectable` compiler for `@Injectable` decorators to the Ivy compiler.\n */\nexport class InjectableDecoratorHandler implements DecoratorHandler<R3InjectableMetadata> {\n  constructor(private reflector: ReflectionHost, private isCore: boolean) {}\n\n  detect(decorator: Decorator[]): Decorator|undefined {\n    return decorator.find(\n        decorator => decorator.name === 'Injectable' && (this.isCore || isAngularCore(decorator)));\n  }\n\n  analyze(node: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<R3InjectableMetadata> {\n    return {\n      analysis: extractInjectableMetadata(node, decorator, this.reflector, this.isCore),\n    };\n  }\n\n  compile(node: ts.ClassDeclaration, analysis: R3InjectableMetadata): CompileResult {\n    const res = compileIvyInjectable(analysis);\n    return {\n      name: 'ngInjectableDef',\n      initializer: res.expression,\n      statements: [],\n      type: res.type,\n    };\n  }\n}\n\n/**\n * Read metadata from the `@Injectable` decorator and produce the `IvyInjectableMetadata`, the input\n * metadata needed to run `compileIvyInjectable`.\n */\nfunction extractInjectableMetadata(\n    clazz: ts.ClassDeclaration, decorator: Decorator, reflector: ReflectionHost,\n    isCore: boolean): R3InjectableMetadata {\n  if (clazz.name === undefined) {\n    throw new Error(`@Injectables must have names`);\n  }\n  const name = clazz.name.text;\n  const type = new WrappedNodeExpr(clazz.name);\n  if (decorator.args === null) {\n    throw new Error(`@Injectable must be called`);\n  }\n  if (decorator.args.length === 0) {\n    return {\n      name,\n      type,\n      providedIn: new LiteralExpr(null),\n      deps: getConstructorDependencies(clazz, reflector, isCore),\n    };\n  } else if (decorator.args.length === 1) {\n    const metaNode = decorator.args[0];\n    // Firstly make sure the decorator argument is an inline literal - if not, it's illegal to\n    // transport references from one location to another. This is the problem that lowering\n    // used to solve - if this restriction proves too undesirable we can re-implement lowering.\n    if (!ts.isObjectLiteralExpression(metaNode)) {\n      throw new Error(`In Ivy, decorator metadata must be inline.`);\n    }\n\n    // Resolve the fields of the literal into a map of field name to expression.\n    const meta = reflectObjectLiteral(metaNode);\n    let providedIn: Expression = new LiteralExpr(null);\n    if (meta.has('providedIn')) {\n      providedIn = new WrappedNodeExpr(meta.get('providedIn') !);\n    }\n    if (meta.has('useValue')) {\n      return {name, type, providedIn, useValue: new WrappedNodeExpr(meta.get('useValue') !)};\n    } else if (meta.has('useExisting')) {\n      return {name, type, providedIn, useExisting: new WrappedNodeExpr(meta.get('useExisting') !)};\n    } else if (meta.has('useClass')) {\n      return {name, type, providedIn, useClass: new WrappedNodeExpr(meta.get('useClass') !)};\n    } else if (meta.has('useFactory')) {\n      // useFactory is special - the 'deps' property must be analyzed.\n      const factory = new WrappedNodeExpr(meta.get('useFactory') !);\n      const deps: R3DependencyMetadata[] = [];\n      if (meta.has('deps')) {\n        const depsExpr = meta.get('deps') !;\n        if (!ts.isArrayLiteralExpression(depsExpr)) {\n          throw new Error(`In Ivy, deps metadata must be inline.`);\n        }\n        if (depsExpr.elements.length > 0) {\n          throw new Error(`deps not yet supported`);\n        }\n        deps.push(...depsExpr.elements.map(dep => getDep(dep, reflector)));\n      }\n      return {name, type, providedIn, useFactory: factory, deps};\n    } else {\n      const deps = getConstructorDependencies(clazz, reflector, isCore);\n      return {name, type, providedIn, deps};\n    }\n  } else {\n    throw new Error(`Too many arguments to @Injectable`);\n  }\n}\n\n\n\nfunction getDep(dep: ts.Expression, reflector: ReflectionHost): R3DependencyMetadata {\n  const meta: R3DependencyMetadata = {\n    token: new WrappedNodeExpr(dep),\n    host: false,\n    resolved: R3ResolvedDependencyType.Token,\n    optional: false,\n    self: false,\n    skipSelf: false,\n  };\n\n  function maybeUpdateDecorator(\n      dec: ts.Identifier, reflector: ReflectionHost, token?: ts.Expression): void {\n    const source = reflector.getImportOfIdentifier(dec);\n    if (source === null || source.from !== '@angular/core') {\n      return;\n    }\n    switch (source.name) {\n      case 'Inject':\n        if (token !== undefined) {\n          meta.token = new WrappedNodeExpr(token);\n        }\n        break;\n      case 'Optional':\n        meta.optional = true;\n        break;\n      case 'SkipSelf':\n        meta.skipSelf = true;\n        break;\n      case 'Self':\n        meta.self = true;\n        break;\n    }\n  }\n\n  if (ts.isArrayLiteralExpression(dep)) {\n    dep.elements.forEach(el => {\n      if (ts.isIdentifier(el)) {\n        maybeUpdateDecorator(el, reflector);\n      } else if (ts.isNewExpression(el) && ts.isIdentifier(el.expression)) {\n        const token = el.arguments && el.arguments.length > 0 && el.arguments[0] || undefined;\n        maybeUpdateDecorator(el.expression, reflector, token);\n      }\n    });\n  }\n  return meta;\n}\n"]}