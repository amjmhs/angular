{"version":3,"file":"r3_factory.js","sourceRoot":"","sources":["../../../../../../packages/compiler/src/render3/r3_factory.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from '../aot/static_symbol';\nimport {CompileTypeMetadata, tokenReference} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {InjectFlags} from '../core';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\nimport {Identifiers as R3} from '../render3/r3_identifiers';\nimport {OutputContext} from '../util';\n\nimport {unsupported} from './view/util';\n\n/**\n * Metadata required by the factory generator to generate a `factory` function for a type.\n */\nexport interface R3FactoryMetadata {\n  /**\n   * String name of the type being generated (used to name the factory function).\n   */\n  name: string;\n\n  /**\n   * An expression representing the function (or constructor) which will instantiate the requested\n   * type.\n   *\n   * This could be a reference to a constructor type, or to a user-defined factory function. The\n   * `useNew` property determines whether it will be called as a constructor or not.\n   */\n  fnOrClass: o.Expression;\n\n  /**\n   * Regardless of whether `fnOrClass` is a constructor function or a user-defined factory, it\n   * may have 0 or more parameters, which will be injected according to the `R3DependencyMetadata`\n   * for those parameters.\n   */\n  deps: R3DependencyMetadata[];\n\n  /**\n   * Whether to interpret `fnOrClass` as a constructor function (`useNew: true`) or as a factory\n   * (`useNew: false`).\n   */\n  useNew: boolean;\n\n\n  /**\n   * An expression for the function which will be used to inject dependencies. The API of this\n   * function could be different, and other options control how it will be invoked.\n   */\n  injectFn: o.ExternalReference;\n}\n\n/**\n * Resolved type of a dependency.\n *\n * Occasionally, dependencies will have special significance which is known statically. In that\n * case the `R3ResolvedDependencyType` informs the factory generator that a particular dependency\n * should be generated specially (usually by calling a special injection function instead of the\n * standard one).\n */\nexport enum R3ResolvedDependencyType {\n  /**\n   * A normal token dependency.\n   */\n  Token = 0,\n\n  /**\n   * The dependency is for an attribute.\n   *\n   * The token expression is a string representing the attribute name.\n   */\n  Attribute = 1,\n\n  /**\n   * The dependency is for the `Injector` type itself.\n   */\n  Injector = 2,\n\n  /**\n   * The dependency is for `ElementRef`.\n   */\n  ElementRef = 3,\n\n  /**\n   * The dependency is for `TemplateRef`.\n   */\n  TemplateRef = 4,\n\n  /**\n   * The dependency is for `ViewContainerRef`.\n   */\n  ViewContainerRef = 5,\n\n  /**\n   * The dependency is for `ChangeDetectorRef`.\n   */\n  ChangeDetectorRef = 6,\n}\n\n/**\n * Metadata representing a single dependency to be injected into a constructor or function call.\n */\nexport interface R3DependencyMetadata {\n  /**\n   * An expression representing the token or value to be injected.\n   */\n  token: o.Expression;\n\n  /**\n   * An enum indicating whether this dependency has special meaning to Angular and needs to be\n   * injected specially.\n   */\n  resolved: R3ResolvedDependencyType;\n\n  /**\n   * Whether the dependency has an @Host qualifier.\n   */\n  host: boolean;\n\n  /**\n   * Whether the dependency has an @Optional qualifier.\n   */\n  optional: boolean;\n\n  /**\n   * Whether the dependency has an @Self qualifier.\n   */\n  self: boolean;\n\n  /**\n   * Whether the dependency has an @SkipSelf qualifier.\n   */\n  skipSelf: boolean;\n}\n\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nexport function compileFactoryFunction(meta: R3FactoryMetadata): o.Expression {\n  // Each dependency becomes an invocation of an inject*() function.\n  const args = meta.deps.map(dep => compileInjectDependency(dep, meta.injectFn));\n\n  // The overall result depends on whether this is construction or function invocation.\n  const expr = meta.useNew ? new o.InstantiateExpr(meta.fnOrClass, args) :\n                             new o.InvokeFunctionExpr(meta.fnOrClass, args);\n\n  return o.fn(\n      [], [new o.ReturnStatement(expr)], o.INFERRED_TYPE, undefined, `${meta.name}_Factory`);\n}\n\nfunction compileInjectDependency(\n    dep: R3DependencyMetadata, injectFn: o.ExternalReference): o.Expression {\n  // Interpret the dependency according to its resolved type.\n  switch (dep.resolved) {\n    case R3ResolvedDependencyType.Token:\n    case R3ResolvedDependencyType.Injector: {\n      // Build up the injection flags according to the metadata.\n      const flags = InjectFlags.Default | (dep.self ? InjectFlags.Self : 0) |\n          (dep.skipSelf ? InjectFlags.SkipSelf : 0) | (dep.host ? InjectFlags.Host : 0) |\n          (dep.optional ? InjectFlags.Optional : 0);\n      // Determine the token used for injection. In almost all cases this is the given token, but\n      // if the dependency is resolved to the `Injector` then the special `INJECTOR` token is used\n      // instead.\n      let token: o.Expression = dep.token;\n      if (dep.resolved === R3ResolvedDependencyType.Injector) {\n        token = o.importExpr(Identifiers.INJECTOR);\n      }\n\n      // Build up the arguments to the injectFn call.\n      const injectArgs = [token];\n      // If this dependency is optional or otherwise has non-default flags, then additional\n      // parameters describing how to inject the dependency must be passed to the inject function\n      // that's being used.\n      if (flags !== InjectFlags.Default || dep.optional) {\n        injectArgs.push(o.literal(flags));\n      }\n      return o.importExpr(injectFn).callFn(injectArgs);\n    }\n    case R3ResolvedDependencyType.Attribute:\n      // In the case of attributes, the attribute name in question is given as the token.\n      return o.importExpr(R3.injectAttribute).callFn([dep.token]);\n    case R3ResolvedDependencyType.ElementRef:\n      return o.importExpr(R3.injectElementRef).callFn([]);\n    case R3ResolvedDependencyType.TemplateRef:\n      return o.importExpr(R3.injectTemplateRef).callFn([]);\n    case R3ResolvedDependencyType.ViewContainerRef:\n      return o.importExpr(R3.injectViewContainerRef).callFn([]);\n    case R3ResolvedDependencyType.ChangeDetectorRef:\n      return o.importExpr(R3.injectChangeDetectorRef).callFn([]);\n    default:\n      return unsupported(\n          `Unknown R3ResolvedDependencyType: ${R3ResolvedDependencyType[dep.resolved]}`);\n  }\n}\n\n/**\n * A helper function useful for extracting `R3DependencyMetadata` from a Render2\n * `CompileTypeMetadata` instance.\n */\nexport function dependenciesFromGlobalMetadata(\n    type: CompileTypeMetadata, outputCtx: OutputContext,\n    reflector: CompileReflector): R3DependencyMetadata[] {\n  // Use the `CompileReflector` to look up references to some well-known Angular types. These will\n  // be compared with the token to statically determine whether the token has significance to\n  // Angular, and set the correct `R3ResolvedDependencyType` as a result.\n  const elementRef = reflector.resolveExternalReference(Identifiers.ElementRef);\n  const templateRef = reflector.resolveExternalReference(Identifiers.TemplateRef);\n  const viewContainerRef = reflector.resolveExternalReference(Identifiers.ViewContainerRef);\n  const injectorRef = reflector.resolveExternalReference(Identifiers.Injector);\n\n  // Iterate through the type's DI dependencies and produce `R3DependencyMetadata` for each of them.\n  const deps: R3DependencyMetadata[] = [];\n  for (let dependency of type.diDeps) {\n    if (dependency.token) {\n      const tokenRef = tokenReference(dependency.token);\n      let resolved: R3ResolvedDependencyType = R3ResolvedDependencyType.Token;\n      if (tokenRef === elementRef) {\n        resolved = R3ResolvedDependencyType.ElementRef;\n      } else if (tokenRef === templateRef) {\n        resolved = R3ResolvedDependencyType.TemplateRef;\n      } else if (tokenRef === viewContainerRef) {\n        resolved = R3ResolvedDependencyType.ViewContainerRef;\n      } else if (tokenRef === injectorRef) {\n        resolved = R3ResolvedDependencyType.Injector;\n      } else if (dependency.isAttribute) {\n        resolved = R3ResolvedDependencyType.Attribute;\n      }\n\n      // In the case of most dependencies, the token will be a reference to a type. Sometimes,\n      // however, it can be a string, in the case of older Angular code or @Attribute injection.\n      const token =\n          tokenRef instanceof StaticSymbol ? outputCtx.importExpr(tokenRef) : o.literal(tokenRef);\n\n      // Construct the dependency.\n      deps.push({\n        token,\n        resolved,\n        host: !!dependency.isHost,\n        optional: !!dependency.isOptional,\n        self: !!dependency.isSelf,\n        skipSelf: !!dependency.isSkipSelf,\n      });\n    } else {\n      unsupported('dependency without a token');\n    }\n  }\n\n  return deps;\n}\n"]}