{"version":3,"file":"symbol_extractor.js","sourceRoot":"","sources":["../../../tools/symbol-extractor/symbol_extractor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as fs from 'fs';\nimport * as ts from 'typescript';\n\n\nexport interface Symbol { name: string; }\n\nexport class SymbolExtractor {\n  public actual: Symbol[];\n\n  static symbolSort(a: Symbol, b: Symbol): number {\n    return a.name == b.name ? 0 : a.name < b.name ? -1 : 1;\n  }\n\n  static parse(path: string, contents: string): Symbol[] {\n    const symbols: Symbol[] = [];\n    const source: ts.SourceFile = ts.createSourceFile(path, contents, ts.ScriptTarget.Latest, true);\n    let fnRecurseDepth = 0;\n    function visitor(child: ts.Node) {\n      // Left for easier debugging.\n      // console.log('>>>', ts.SyntaxKind[child.kind]);\n      switch (child.kind) {\n        case ts.SyntaxKind.FunctionExpression:\n          fnRecurseDepth++;\n          if (fnRecurseDepth <= 1) {\n            ts.forEachChild(child, visitor);\n          }\n          fnRecurseDepth--;\n          break;\n        case ts.SyntaxKind.SourceFile:\n        case ts.SyntaxKind.VariableStatement:\n        case ts.SyntaxKind.VariableDeclarationList:\n        case ts.SyntaxKind.ExpressionStatement:\n        case ts.SyntaxKind.CallExpression:\n        case ts.SyntaxKind.ParenthesizedExpression:\n        case ts.SyntaxKind.Block:\n        case ts.SyntaxKind.PrefixUnaryExpression:\n          ts.forEachChild(child, visitor);\n          break;\n        case ts.SyntaxKind.VariableDeclaration:\n          const varDecl = child as ts.VariableDeclaration;\n          if (varDecl.initializer && fnRecurseDepth !== 0) {\n            symbols.push({name: varDecl.name.getText()});\n          }\n          if (fnRecurseDepth == 0 && isRollupExportSymbol(varDecl)) {\n            ts.forEachChild(child, visitor);\n          }\n          break;\n        case ts.SyntaxKind.FunctionDeclaration:\n          const funcDecl = child as ts.FunctionDeclaration;\n          funcDecl.name && symbols.push({name: funcDecl.name.getText()});\n          break;\n        default:\n          // Left for easier debugging.\n          // console.log('###', ts.SyntaxKind[child.kind], child.getText());\n      }\n      if (symbols.length && symbols[symbols.length - 1].name == 'type') {\n        debugger;\n      }\n    }\n    visitor(source);\n    symbols.sort(SymbolExtractor.symbolSort);\n    return symbols;\n  }\n\n  static diff(actual: Symbol[], expected: string|((Symbol | string)[])): {[name: string]: string} {\n    if (typeof expected == 'string') {\n      expected = JSON.parse(expected);\n    }\n    const diff: {[name: string]: ('missing' | 'extra')} = {};\n    (expected as(Symbol | string)[]).forEach((nameOrSymbol) => {\n      diff[typeof nameOrSymbol == 'string' ? nameOrSymbol : nameOrSymbol.name] = 'missing';\n    });\n\n    actual.forEach((s) => {\n      if (diff[s.name] === 'missing') {\n        delete diff[s.name];\n      } else {\n        diff[s.name] = 'extra';\n      }\n    });\n    return diff;\n  }\n\n  constructor(private path: string, private contents: string) {\n    this.actual = SymbolExtractor.parse(path, contents);\n  }\n\n  expect(expectedSymbols: (string|Symbol)[]) {\n    expect(SymbolExtractor.diff(this.actual, expectedSymbols)).toEqual({});\n  }\n\n  compareAndPrintError(goldenFilePath: string, expected: string|((Symbol | string)[])): boolean {\n    let passed = true;\n    const diff = SymbolExtractor.diff(this.actual, expected);\n    Object.keys(diff).forEach((key) => {\n      if (passed) {\n        console.error(`Expected symbols in '${this.path}' did not match gold file.`);\n        passed = false;\n      }\n      console.error(`   Symbol: ${key} => ${diff[key]}`);\n    });\n\n    return passed;\n  }\n}\n\nfunction toSymbol(v: string | Symbol): Symbol {\n  return typeof v == 'string' ? {'name': v} : v as Symbol;\n}\n\nfunction toName(symbol: Symbol): string {\n  return symbol.name;\n}\n\n/**\n * Detects if VariableDeclarationList is format `var ..., bundle = function(){}()`;\n *\n * Rollup produces this format when it wants to export symbols from a bundle.\n * @param child\n */\nfunction isRollupExportSymbol(decl: ts.VariableDeclaration): boolean {\n  return !!(decl.initializer && decl.initializer.kind == ts.SyntaxKind.CallExpression) &&\n      ts.isIdentifier(decl.name) && decl.name.text === 'bundle';\n}"]}