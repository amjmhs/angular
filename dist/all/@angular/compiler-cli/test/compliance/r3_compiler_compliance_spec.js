"use strict";
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var test_util_1 = require("@angular/compiler/test/aot/test_util");
var mock_compile_1 = require("./mock_compile");
/* These tests are codified version of the tests in compiler_canonical_spec.ts. Every
  * test in compiler_canonical_spec.ts should have a corresponding test here.
  */
describe('compiler compliance', function () {
    var angularFiles = test_util_1.setup({
        compileAngular: true,
        compileAnimations: false,
        compileCommon: true,
    });
    describe('elements', function () {
        it('should handle SVG', function () {
            var files = {
                app: {
                    'spec.ts': "\n              import {Component, NgModule} from '@angular/core';\n\n              @Component({\n                selector: 'my-component',\n                template: `<div class=\"my-app\" title=\"Hello\"><svg><circle cx=\"20\" cy=\"30\" r=\"50\"/></svg><p>test</p></div>`\n              })\n              export class MyComponent {}\n\n              @NgModule({declarations: [MyComponent]})\n              export class MyModule {}\n          "
                }
            };
            // The factory should look like this:
            var factory = 'factory: function MyComponent_Factory() { return new MyComponent(); }';
            // The template should look like this (where IDENT is a wild card for an identifier):
            var template = "\n        const $c1$ = [\"title\", \"Hello\"];\n        const $c2$ = [\"my-app\", " + 1 /* VALUES_MODE */ + ", \"my-app\", true];\n        const $c3$ = [\"cx\", \"20\", \"cy\", \"30\", \"r\", \"50\"];\n        \u2026\n        template: function MyComponent_Template(rf, ctx) {\n          if (rf & 1) {\n            $r3$.\u0275E(0, \"div\", $c1$);\n            $r3$.\u0275s($c2$);\n            $r3$.\u0275NS();\n            $r3$.\u0275E(1, \"svg\");\n            $r3$.\u0275Ee(2, \"circle\", $c3$);\n            $r3$.\u0275e();\n            $r3$.\u0275NH();\n            $r3$.\u0275E(3, \"p\");\n            $r3$.\u0275T(4, \"test\");\n            $r3$.\u0275e();\n            $r3$.\u0275e();\n          }\n        }\n      ";
            var result = mock_compile_1.compile(files, angularFiles);
            mock_compile_1.expectEmit(result.source, factory, 'Incorrect factory');
            mock_compile_1.expectEmit(result.source, template, 'Incorrect template');
        });
        it('should handle MathML', function () {
            var files = {
                app: {
                    'spec.ts': "\n              import {Component, NgModule} from '@angular/core';\n\n              @Component({\n                selector: 'my-component',\n                template: `<div class=\"my-app\" title=\"Hello\"><math><infinity/></math><p>test</p></div>`\n              })\n              export class MyComponent {}\n\n              @NgModule({declarations: [MyComponent]})\n              export class MyModule {}\n          "
                }
            };
            // The factory should look like this:
            var factory = 'factory: function MyComponent_Factory() { return new MyComponent(); }';
            // The template should look like this (where IDENT is a wild card for an identifier):
            var template = "\n        const $c1$ = [\"title\", \"Hello\"];\n        const $c2$ = [\"my-app\", " + 1 /* VALUES_MODE */ + ", \"my-app\", true];\n        \u2026\n        template: function MyComponent_Template(rf, ctx) {\n          if (rf & 1) {\n            $r3$.\u0275E(0, \"div\", $c1$);\n            $r3$.\u0275s($c2$);\n            $r3$.\u0275NM();\n            $r3$.\u0275E(1, \"math\");\n            $r3$.\u0275Ee(2, \"infinity\");\n            $r3$.\u0275e();\n            $r3$.\u0275NH();\n            $r3$.\u0275E(3, \"p\");\n            $r3$.\u0275T(4, \"test\");\n            $r3$.\u0275e();\n            $r3$.\u0275e();\n          }\n        }\n      ";
            var result = mock_compile_1.compile(files, angularFiles);
            mock_compile_1.expectEmit(result.source, factory, 'Incorrect factory');
            mock_compile_1.expectEmit(result.source, template, 'Incorrect template');
        });
        it('should translate DOM structure', function () {
            var files = {
                app: {
                    'spec.ts': "\n              import {Component, NgModule} from '@angular/core';\n\n              @Component({\n                selector: 'my-component',\n                template: `<div class=\"my-app\" title=\"Hello\">Hello <b>World</b>!</div>`\n              })\n              export class MyComponent {}\n\n              @NgModule({declarations: [MyComponent]})\n              export class MyModule {}\n          "
                }
            };
            // The factory should look like this:
            var factory = 'factory: function MyComponent_Factory() { return new MyComponent(); }';
            // The template should look like this (where IDENT is a wild card for an identifier):
            var template = "\n        const $c1$ = [\"title\", \"Hello\"];\n        const $c2$ = [\"my-app\", " + 1 /* VALUES_MODE */ + ", \"my-app\", true];\n        \u2026\n        template: function MyComponent_Template(rf, ctx) {\n          if (rf & 1) {\n            $r3$.\u0275E(0, \"div\", $c1$);\n            $r3$.\u0275s($c2$);\n            $r3$.\u0275T(1, \"Hello \");\n            $r3$.\u0275E(2, \"b\");\n            $r3$.\u0275T(3, \"World\");\n            $r3$.\u0275e();\n            $r3$.\u0275T(4, \"!\");\n            $r3$.\u0275e();\n          }\n        }\n      ";
            var result = mock_compile_1.compile(files, angularFiles);
            mock_compile_1.expectEmit(result.source, factory, 'Incorrect factory');
            mock_compile_1.expectEmit(result.source, template, 'Incorrect template');
        });
        // TODO(https://github.com/angular/angular/issues/24426): We need to support the parser actually
        // building the proper attributes based off of xmlns atttribuates.
        xit('should support namspaced attributes', function () {
            var files = {
                app: {
                    'spec.ts': "\n                import {Component, NgModule} from '@angular/core';\n\n                @Component({\n                  selector: 'my-component',\n                  template: `<div xmlns:foo=\"http://someuri/foo\" class=\"my-app\" foo:bar=\"baz\" title=\"Hello\" foo:qux=\"quacks\">Hello <b>World</b>!</div>`\n                })\n                export class MyComponent {}\n\n                @NgModule({declarations: [MyComponent]})\n                export class MyModule {}\n            "
                }
            };
            // The factory should look like this:
            var factory = 'factory: function MyComponent_Factory() { return new MyComponent(); }';
            // The template should look like this (where IDENT is a wild card for an identifier):
            var template = "\n          const $c1$ = [\"class\", \"my-app\", 0, \"http://someuri/foo\", \"foo:bar\", \"baz\", \"title\", \"Hello\", 0, \"http://someuri/foo\", \"foo:qux\", \"quacks\"];\n          \u2026\n          template: function MyComponent_Template(rf, ctx) {\n            if (rf & 1) {\n              $r3$.\u0275E(0, \"div\", $e0_attrs$);\n              $r3$.\u0275T(1, \"Hello \");\n              $r3$.\u0275E(2, \"b\");\n              $r3$.\u0275T(3, \"World\");\n              $r3$.\u0275e();\n              $r3$.\u0275T(4, \"!\");\n              $r3$.\u0275e();\n            }\n          }\n        ";
            var result = mock_compile_1.compile(files, angularFiles);
            mock_compile_1.expectEmit(result.source, factory, 'Incorrect factory');
            mock_compile_1.expectEmit(result.source, template, 'Incorrect template');
        });
        it('should bind to element properties', function () {
            var files = {
                app: {
                    'spec.ts': "\n              import {Component, NgModule} from '@angular/core';\n\n              @Component({\n                selector: 'my-component',\n                template: `<div [id]=\"id\"></div>`\n              })\n              export class MyComponent {\n                id = 'one';\n              }\n\n              @NgModule({declarations: [MyComponent]})\n              export class MyModule {}\n          "
                }
            };
            var factory = 'factory: function MyComponent_Factory() { return new MyComponent(); }';
            var template = "\n        template: function MyComponent_Template(rf, ctx) {\n          if (rf & 1) {\n            $r3$.\u0275Ee(0, \"div\");\n          }\n          if (rf & 2) {\n            $r3$.\u0275p(0, \"id\", $r3$.\u0275b(ctx.id));\n          }\n        }\n      ";
            var result = mock_compile_1.compile(files, angularFiles);
            mock_compile_1.expectEmit(result.source, factory, 'Incorrect factory');
            mock_compile_1.expectEmit(result.source, template, 'Incorrect template');
        });
        it('should reserve slots for pure functions', function () {
            var files = {
                app: {
                    'spec.ts': "\n              import {Component, NgModule} from '@angular/core';\n\n              @Component({\n                selector: 'my-component',\n                template: `<div\n                  [ternary]=\"cond ? [a] : [0]\"\n                  [pipe]=\"value | pipe:1:2\"\n                  [and]=\"cond && [b]\"\n                  [or]=\"cond || [c]\"\n                ></div>`\n              })\n              export class MyComponent {\n                id = 'one';\n              }\n\n              @NgModule({declarations: [MyComponent]})\n              export class MyModule {}\n          "
                }
            };
            var factory = 'factory: function MyComponent_Factory() { return new MyComponent(); }';
            var template = "\n        template: function MyComponent_Template(rf, ctx) {\n          if (rf & 1) {\n            $r3$.\u0275Ee(0, \"div\");\n            $r3$.\u0275Pp(1,\"pipe\");\n            $r3$.\u0275rS(10);\n          }\n          if (rf & 2) {\n            $r3$.\u0275p(0, \"ternary\", $r3$.\u0275b((ctx.cond ? $r3$.\u0275f1(2, _c0, ctx.a): _c1)));\n            $r3$.\u0275p(0, \"pipe\", $r3$.\u0275b($r3$.\u0275pb3(6, 1, ctx.value, 1, 2)));\n            $r3$.\u0275p(0, \"and\", $r3$.\u0275b((ctx.cond && $r3$.\u0275f1(4, _c0, ctx.b))));\n            $r3$.\u0275p(0, \"or\", $r3$.\u0275b((ctx.cond || $r3$.\u0275f1(6, _c0, ctx.c))));\n          }\n        }\n      ";
            var result = mock_compile_1.compile(files, angularFiles);
            mock_compile_1.expectEmit(result.source, factory, 'Incorrect factory');
            mock_compile_1.expectEmit(result.source, template, 'Incorrect template');
        });
        it('should bind to class and style names', function () {
            var files = {
                app: {
                    'spec.ts': "\n              import {Component, NgModule} from '@angular/core';\n\n              @Component({\n                selector: 'my-component',\n                template: `<div [class.error]=\"error\" [style.background-color]=\"color\"></div>`\n              })\n              export class MyComponent {\n                error = true;\n                color = 'red';\n              }\n\n              @NgModule({declarations: [MyComponent]})\n              export class MyModule {}\n          "
                }
            };
            var factory = 'factory: function MyComponent_Factory() { return new MyComponent(); }';
            var template = "\n        const _c0 = [\"error\"];\n        const _c1 = [\"background-color\"];\n        \u2026\n        MyComponent.ngComponentDef = i0.\u0275defineComponent({type:MyComponent,selectors:[[\"my-component\"]],\n            factory:function MyComponent_Factory(){\n              return new MyComponent();\n            },template:function MyComponent_Template(rf,ctx){\n              if (rf & 1) {\n                $r3$.\u0275E(0, \"div\");\n                $r3$.\u0275s(_c0, _c1);\n                $r3$.\u0275e();\n              }\n              if (rf & 2) {\n                $r3$.\u0275sp(0, 0, ctx.color);\n                $r3$.\u0275cp(0, 0, ctx.error);\n                $r3$.\u0275sa(0);\n              }\n            }\n        });\n      ";
            var result = mock_compile_1.compile(files, angularFiles);
            mock_compile_1.expectEmit(result.source, factory, 'Incorrect factory');
            mock_compile_1.expectEmit(result.source, template, 'Incorrect template');
        });
    });
    describe('components & directives', function () {
        it('should instantiate directives', function () {
            var files = {
                app: {
                    'spec.ts': "\n            import {Component, Directive, NgModule} from '@angular/core';\n\n            @Component({selector: 'child', template: 'child-view'})\n            export class ChildComponent {}\n\n            @Directive({selector: '[some-directive]'})\n            export class SomeDirective {}\n\n            @Component({selector: 'my-component', template: '<child some-directive></child>!'})\n            export class MyComponent {}\n\n            @NgModule({declarations: [ChildComponent, SomeDirective, MyComponent]})\n            export class MyModule{}\n          "
                }
            };
            // ChildComponent definition should be:
            var ChildComponentDefinition = "\n        ChildComponent.ngComponentDef = $r3$.\u0275defineComponent({\n          type: ChildComponent,\n          selectors: [[\"child\"]],\n          factory: function ChildComponent_Factory() { return new ChildComponent(); },\n          template: function ChildComponent_Template(rf, ctx) {\n            if (rf & 1) {\n              $r3$.\u0275T(0, \"child-view\");\n            }\n          }\n        });";
            // SomeDirective definition should be:
            var SomeDirectiveDefinition = "\n        SomeDirective.ngDirectiveDef = $r3$.\u0275defineDirective({\n          type: SomeDirective,\n          selectors: [[\"\", \"some-directive\", \"\"]],\n          factory: function SomeDirective_Factory() {return new SomeDirective(); }\n        });\n      ";
            // MyComponent definition should be:
            var MyComponentDefinition = "\n        const $c1$ = [\"some-directive\", \"\"];\n        \u2026\n        MyComponent.ngComponentDef = $r3$.\u0275defineComponent({\n          type: MyComponent,\n          selectors: [[\"my-component\"]],\n          factory: function MyComponent_Factory() { return new MyComponent(); },\n          template: function MyComponent_Template(rf, ctx) {\n            if (rf & 1) {\n              $r3$.\u0275Ee(0, \"child\", $c1$);\n              $r3$.\u0275T(1, \"!\");\n            }\n          },\n          directives: [ChildComponent, SomeDirective]\n        });\n      ";
            var result = mock_compile_1.compile(files, angularFiles);
            var source = result.source;
            mock_compile_1.expectEmit(source, ChildComponentDefinition, 'Incorrect ChildComponent.ngComponentDef');
            mock_compile_1.expectEmit(source, SomeDirectiveDefinition, 'Incorrect SomeDirective.ngDirectiveDef');
            mock_compile_1.expectEmit(source, MyComponentDefinition, 'Incorrect MyComponentDefinition.ngComponentDef');
        });
        it('should support complex selectors', function () {
            var files = {
                app: {
                    'spec.ts': "\n            import {Directive, NgModule} from '@angular/core';\n\n            @Directive({selector: 'div.foo[some-directive]:not([title]):not(.baz)'})\n            export class SomeDirective {}\n\n            @Directive({selector: ':not(span[title]):not(.baz)'})\n            export class OtherDirective {}\n\n            @NgModule({declarations: [SomeDirective, OtherDirective]})\n            export class MyModule{}\n          "
                }
            };
            // SomeDirective definition should be:
            var SomeDirectiveDefinition = "\n        SomeDirective.ngDirectiveDef = $r3$.\u0275defineDirective({\n          type: SomeDirective,\n          selectors: [[\"div\", \"some-directive\", \"\", 8, \"foo\", 3, \"title\", \"\", 9, \"baz\"]],\n          factory: function SomeDirective_Factory() {return new SomeDirective(); }\n        });\n      ";
            // OtherDirective definition should be:
            var OtherDirectiveDefinition = "\n        OtherDirective.ngDirectiveDef = $r3$.\u0275defineDirective({\n          type: OtherDirective,\n          selectors: [[\"\", 5, \"span\", \"title\", \"\", 9, \"baz\"]],\n          factory: function OtherDirective_Factory() {return new OtherDirective(); }\n        });\n      ";
            var result = mock_compile_1.compile(files, angularFiles);
            var source = result.source;
            mock_compile_1.expectEmit(source, SomeDirectiveDefinition, 'Incorrect SomeDirective.ngDirectiveDef');
            mock_compile_1.expectEmit(source, OtherDirectiveDefinition, 'Incorrect OtherDirective.ngDirectiveDef');
        });
        it('should support host bindings', function () {
            var files = {
                app: {
                    'spec.ts': "\n            import {Directive, HostBinding, NgModule} from '@angular/core';\n\n            @Directive({selector: '[hostBindingDir]'})\n            export class HostBindingDir {\n              @HostBinding('id') dirId = 'some id';\n            }\n\n            @NgModule({declarations: [HostBindingDir]})\n            export class MyModule {}\n          "
                }
            };
            var HostBindingDirDeclaration = "\n        HostBindingDir.ngDirectiveDef = $r3$.\u0275defineDirective({\n          type: HostBindingDir,\n          selectors: [[\"\", \"hostBindingDir\", \"\"]],\n          factory: function HostBindingDir_Factory() { return new HostBindingDir(); },\n          hostBindings: function HostBindingDir_HostBindings(dirIndex, elIndex) {\n            $r3$.\u0275p(elIndex, \"id\", $r3$.\u0275b($r3$.\u0275d(dirIndex).dirId));\n          }\n        });\n      ";
            var result = mock_compile_1.compile(files, angularFiles);
            var source = result.source;
            mock_compile_1.expectEmit(source, HostBindingDirDeclaration, 'Invalid host binding code');
        });
        it('should support structural directives', function () {
            var files = {
                app: {
                    'spec.ts': "\n            import {Component, Directive, NgModule, TemplateRef} from '@angular/core';\n\n            @Directive({selector: '[if]'})\n            export class IfDirective {\n              constructor(template: TemplateRef<any>) { }\n            }\n\n            @Component({\n              selector: 'my-component',\n              template: '<ul #foo><li *if>{{salutation}} {{foo}}</li></ul>'\n            })\n            export class MyComponent {\n              salutation = 'Hello';\n            }\n\n            @NgModule({declarations: [IfDirective, MyComponent]})\n            export class MyModule {}\n            "
                }
            };
            var IfDirectiveDefinition = "\n        IfDirective.ngDirectiveDef = $r3$.\u0275defineDirective({\n          type: IfDirective,\n          selectors: [[\"\", \"if\", \"\"]],\n          factory: function IfDirective_Factory() { return new IfDirective($r3$.\u0275injectTemplateRef()); }\n        });";
            var MyComponentDefinition = "\n        const $c1$ = [\"foo\", \"\"];\n        const $c2$ = [\"if\", \"\"];\n        \u2026\n        MyComponent.ngComponentDef = $r3$.\u0275defineComponent({\n          type: MyComponent,\n          selectors: [[\"my-component\"]],\n          factory: function MyComponent_Factory() { return new MyComponent(); },\n          template: function MyComponent_Template(rf, ctx) {\n            if (rf & 1) {\n              $r3$.\u0275E(0, \"ul\", null, $c1$);\n              $r3$.\u0275C(2, MyComponent_li_Template_2, null, $c2$);\n              $r3$.\u0275e();\n            }\n            const $foo$ = $r3$.\u0275ld(1);\n            function MyComponent_li_Template_2(rf, ctx0) {\n              if (rf & 1) {\n                $r3$.\u0275E(0, \"li\");\n                $r3$.\u0275T(1);\n                $r3$.\u0275e();\n              }\n              if (rf & 2) {\n                $r3$.\u0275t(1, $r3$.\u0275i2(\"\", ctx.salutation, \" \", $foo$, \"\"));\n              }\n            }\n          },\n          directives:[IfDirective]\n        });";
            var result = mock_compile_1.compile(files, angularFiles);
            var source = result.source;
            mock_compile_1.expectEmit(source, IfDirectiveDefinition, 'Incorrect IfDirective.ngDirectiveDef');
            mock_compile_1.expectEmit(source, MyComponentDefinition, 'Incorrect MyComponent.ngComponentDef');
        });
        describe('value composition', function () {
            it('should support array literals', function () {
                var files = {
                    app: {
                        'spec.ts': "\n              import {Component, Input, NgModule} from '@angular/core';\n\n              @Component({\n                selector: 'my-comp',\n                template: `\n                  <p>{{ names[0] }}</p>\n                  <p>{{ names[1] }}</p>\n                `\n              })\n              export class MyComp {\n                @Input() names: string[];\n              }\n\n              @Component({\n                selector: 'my-app',\n                template: `\n                <my-comp [names]=\"['Nancy', customName]\"></my-comp>\n              `\n              })\n              export class MyApp {\n                customName = 'Bess';\n              }\n\n              @NgModule({declarations: [MyComp, MyApp]})\n              export class MyModule { }\n            "
                    }
                };
                var MyAppDeclaration = "\n          const $e0_ff$ = function ($v$) { return [\"Nancy\", $v$]; };\n          \u2026\n          MyApp.ngComponentDef = $r3$.\u0275defineComponent({\n            type: MyApp,\n            selectors: [[\"my-app\"]],\n            factory: function MyApp_Factory() { return new MyApp(); },\n            template: function MyApp_Template(rf, ctx) {\n              if (rf & 1) {\n                $r3$.\u0275Ee(0, \"my-comp\");\n                $r3$.\u0275rS(2);\n              }\n              if (rf & 2) {\n                $r3$.\u0275p(0, \"names\", $r3$.\u0275b($r3$.\u0275f1(2, $e0_ff$, ctx.customName)));\n              }\n            },\n           directives: [MyComp]\n          });\n        ";
                var result = mock_compile_1.compile(files, angularFiles);
                var source = result.source;
                mock_compile_1.expectEmit(source, MyAppDeclaration, 'Invalid array emit');
            });
            it('should support 9+ bindings in array literals', function () {
                var files = {
                    app: {
                        'spec.ts': "\n              import {Component, Input, NgModule} from '@angular/core';\n\n              @Component({\n                selector: 'my-comp',\n                template: `\n                  {{ names[0] }}\n                  {{ names[1] }}\n                  {{ names[3] }}\n                  {{ names[4] }}\n                  {{ names[5] }}\n                  {{ names[6] }}\n                  {{ names[7] }}\n                  {{ names[8] }}\n                  {{ names[9] }}\n                  {{ names[10] }}\n                  {{ names[11] }}\n                `\n              })\n              export class MyComp {\n                @Input() names: string[];\n              }\n\n              @Component({\n                selector: 'my-app',\n                template: `\n                <my-comp [names]=\"['start-', n0, n1, n2, n3, n4, '-middle-', n5, n6, n7, n8, '-end']\">\n                </my-comp>\n              `\n              })\n              export class MyApp {\n                n0 = 'a';\n                n1 = 'b';\n                n2 = 'c';\n                n3 = 'd';\n                n4 = 'e';\n                n5 = 'f';\n                n6 = 'g';\n                n7 = 'h';\n                n8 = 'i';\n              }\n\n              @NgModule({declarations: [MyComp, MyApp]})\n              export class MyModule {}\n              "
                    }
                };
                var MyAppDefinition = "\n          const $e0_ff$ = function ($v0$, $v1$, $v2$, $v3$, $v4$, $v5$, $v6$, $v7$, $v8$) {\n            return [\"start-\", $v0$, $v1$, $v2$, $v3$, $v4$, \"-middle-\", $v5$, $v6$, $v7$, $v8$, \"-end\"];\n          }\n          \u2026\n          MyApp.ngComponentDef = $r3$.\u0275defineComponent({\n            type: MyApp,\n            selectors: [[\"my-app\"]],\n            factory: function MyApp_Factory() { return new MyApp(); },\n            template: function MyApp_Template(rf, ctx) {\n              if (rf & 1) {\n                $r3$.\u0275Ee(0, \"my-comp\");\n                $r3$.\u0275rS(10);\n              }\n              if (rf & 2) {\n                $r3$.\u0275p(\n                    0, \"names\",\n                    $r3$.\u0275b($r3$.\u0275fV(10, $e0_ff$, [ctx.n0, ctx.n1, ctx.n2, ctx.n3, ctx.n4, ctx.n5, ctx.n6, ctx.n7, ctx.n8])));\n              }\n            },\n            directives: [MyComp]\n          });\n        ";
                var result = mock_compile_1.compile(files, angularFiles);
                var source = result.source;
                mock_compile_1.expectEmit(source, MyAppDefinition, 'Invalid array binding');
            });
            it('should support object literals', function () {
                var files = {
                    app: {
                        'spec.ts': "\n                import {Component, Input, NgModule} from '@angular/core';\n\n                @Component({\n                  selector: 'object-comp',\n                  template: `\n                    <p> {{ config['duration'] }} </p>\n                    <p> {{ config.animation }} </p>\n                  `\n                })\n                export class ObjectComp {\n                  @Input() config: {[key: string]: any};\n                }\n\n                @Component({\n                  selector: 'my-app',\n                  template: `\n                  <object-comp [config]=\"{'duration': 500, animation: name}\"></object-comp>\n                `\n                })\n                export class MyApp {\n                  name = 'slide';\n                }\n\n                @NgModule({declarations: [ObjectComp, MyApp]})\n                export class MyModule {}\n              "
                    }
                };
                var MyAppDefinition = "\n          const $e0_ff$ = function ($v$) { return {\"duration\": 500, animation: $v$}; };\n          \u2026\n          MyApp.ngComponentDef = $r3$.\u0275defineComponent({\n            type: MyApp,\n            selectors: [[\"my-app\"]],\n            factory: function MyApp_Factory() { return new MyApp(); },\n            template: function MyApp_Template(rf, ctx) {\n              if (rf & 1) {\n                $r3$.\u0275Ee(0, \"object-comp\");\n                $r3$.\u0275rS(2);\n              }\n              if (rf & 2) {\n                $r3$.\u0275p(0, \"config\", $r3$.\u0275b($r3$.\u0275f1(2, $e0_ff$, ctx.name)));\n              }\n            },\n            directives: [ObjectComp]\n          });\n        ";
                var result = mock_compile_1.compile(files, angularFiles);
                var source = result.source;
                mock_compile_1.expectEmit(source, MyAppDefinition, 'Invalid object literal binding');
            });
            it('should support expressions nested deeply in object/array literals', function () {
                var files = {
                    app: {
                        'spec.ts': "\n              import {Component, Input, NgModule} from '@angular/core';\n\n              @Component({\n                selector: 'nested-comp',\n                template: `\n                  <p> {{ config.animation }} </p>\n                  <p> {{config.actions[0].opacity }} </p>\n                  <p> {{config.actions[1].duration }} </p>\n                `\n              })\n              export class NestedComp {\n                @Input() config: {[key: string]: any};\n              }\n\n              @Component({\n                selector: 'my-app',\n                template: `\n                <nested-comp [config]=\"{animation: name, actions: [{ opacity: 0, duration: 0}, {opacity: 1, duration: duration }]}\">\n                </nested-comp>\n              `\n              })\n              export class MyApp {\n                name = 'slide';\n                duration = 100;\n              }\n\n              @NgModule({declarations: [NestedComp, MyApp]})\n              export class MyModule {}\n              "
                    }
                };
                var MyAppDefinition = "\n          const $c0$ = {opacity: 0, duration: 0};\n          const $e0_ff$ = function ($v$) { return {opacity: 1, duration: $v$}; };\n          const $e0_ff_1$ = function ($v$) { return [$c0$, $v$]; };\n          const $e0_ff_2$ = function ($v1$, $v2$) { return {animation: $v1$, actions: $v2$}; };\n          \u2026\n          MyApp.ngComponentDef = $r3$.\u0275defineComponent({\n            type: MyApp,\n            selectors: [[\"my-app\"]],\n            factory: function MyApp_Factory() { return new MyApp(); },\n            template: function MyApp_Template(rf, ctx) {\n              if (rf & 1) {\n                $r3$.\u0275Ee(0, \"nested-comp\");\n                $r3$.\u0275rS(7);\n              }\n              if (rf & 2) {\n                $r3$.\u0275p(\n                    0, \"config\",\n                    $r3$.\u0275b($r3$.\u0275f2(7, $e0_ff_2$, ctx.name, $r3$.\u0275f1(4, $e0_ff_1$, $r3$.\u0275f1(2, $e0_ff$, ctx.duration)))));\n              }\n            },\n            directives: [NestedComp]\n          });\n        ";
                var result = mock_compile_1.compile(files, angularFiles);
                var source = result.source;
                mock_compile_1.expectEmit(source, MyAppDefinition, 'Invalid array/object literal binding');
            });
        });
        it('should support content projection', function () {
            var files = {
                app: {
                    'spec.ts': "\n            import {Component, Directive, NgModule, TemplateRef} from '@angular/core';\n\n            @Component({selector: 'simple', template: '<div><ng-content></ng-content></div>'})\n            export class SimpleComponent {}\n\n            @Component({\n              selector: 'complex',\n              template: `\n                <div id=\"first\"><ng-content select=\"span[title=toFirst]\"></ng-content></div>\n                <div id=\"second\"><ng-content select=\"span[title=toSecond]\"></ng-content></div>`\n              })\n            export class ComplexComponent { }\n\n            @NgModule({declarations: [SimpleComponent, ComplexComponent]})\n            export class MyModule {}\n\n            @Component({\n              selector: 'my-app',\n              template: '<simple>content</simple> <complex></complex>'\n            })\n            export class MyApp {}\n          "
                }
            };
            var SimpleComponentDefinition = "\n        SimpleComponent.ngComponentDef = $r3$.\u0275defineComponent({\n          type: SimpleComponent,\n          selectors: [[\"simple\"]],\n          factory: function SimpleComponent_Factory() { return new SimpleComponent(); },\n          template: function SimpleComponent_Template(rf, ctx) {\n            if (rf & 1) {\n              $r3$.\u0275pD();\n              $r3$.\u0275E(0, \"div\");\n              $r3$.\u0275P(1);\n              $r3$.\u0275e();\n            }\n          }\n        });";
            var ComplexComponentDefinition = "\n        const $c1$ = [[[\"span\", \"title\", \"tofirst\"]], [[\"span\", \"title\", \"tosecond\"]]];\n        const $c2$ = [\"span[title=toFirst]\", \"span[title=toSecond]\"];\n        const $c3$ = [\"id\",\"first\"];\n        const $c4$ = [\"id\",\"second\"];\n        \u2026\n        ComplexComponent.ngComponentDef = $r3$.\u0275defineComponent({\n          type: ComplexComponent,\n          selectors: [[\"complex\"]],\n          factory: function ComplexComponent_Factory() { return new ComplexComponent(); },\n          template: function ComplexComponent_Template(rf, ctx) {\n            if (rf & 1) {\n              $r3$.\u0275pD($c1$, $c2$);\n              $r3$.\u0275E(0, \"div\", $c3$);\n              $r3$.\u0275P(1, 1);\n              $r3$.\u0275e();\n              $r3$.\u0275E(2, \"div\", $c4$);\n              $r3$.\u0275P(3, 2);\n              $r3$.\u0275e();\n            }\n          }\n        });\n      ";
            var result = mock_compile_1.compile(files, angularFiles);
            var source = result.source;
            mock_compile_1.expectEmit(result.source, SimpleComponentDefinition, 'Incorrect SimpleComponent definition');
            mock_compile_1.expectEmit(result.source, ComplexComponentDefinition, 'Incorrect ComplexComponent definition');
        });
        describe('queries', function () {
            var directive = {
                'some.directive.ts': "\n          import {Directive} from '@angular/core';\n\n          @Directive({\n            selector: '[someDir]',\n          })\n          export class SomeDirective { }\n        "
            };
            it('should support view queries', function () {
                var files = {
                    app: __assign({}, directive, { 'view_query.component.ts': "\n            import {Component, NgModule, ViewChild} from '@angular/core';\n            import {SomeDirective} from './some.directive';\n\n            @Component({\n              selector: 'view-query-component',\n              template: `\n              <div someDir></div>\n              `\n            })\n            export class ViewQueryComponent {\n              @ViewChild(SomeDirective) someDir: SomeDirective;\n            }\n\n            @NgModule({declarations: [SomeDirective, ViewQueryComponent]})\n            export class MyModule {}\n          " })
                };
                var ViewQueryComponentDefinition = "\n          const $e0_attrs$ = [\"someDir\",\"\"];\n          \u2026\n          ViewQueryComponent.ngComponentDef = $r3$.\u0275defineComponent({\n            type: ViewQueryComponent,\n            selectors: [[\"view-query-component\"]],\n            factory: function ViewQueryComponent_Factory() { return new ViewQueryComponent(); },\n            viewQuery: function ViewQueryComponent_Query(rf, ctx) {\n              if (rf & 1) {\n                $r3$.\u0275Q(0, SomeDirective, true);\n              }\n              if (rf & 2) {\n                var $tmp$;\n                ($r3$.\u0275qR(($tmp$ = $r3$.\u0275ld(0))) && (ctx.someDir = $tmp$.first));\n              }\n            },\n            template: function ViewQueryComponent_Template(rf, ctx) {\n              if (rf & 1) {\n                $r3$.\u0275Ee(1, \"div\", $e0_attrs$);\n              }\n            },\n            directives:[SomeDirective]\n          });";
                var result = mock_compile_1.compile(files, angularFiles);
                var source = result.source;
                mock_compile_1.expectEmit(source, ViewQueryComponentDefinition, 'Invalid ViewQuery declaration');
            });
            it('should support content queries', function () {
                var files = {
                    app: __assign({}, directive, { 'spec.ts': "\n            import {Component, ContentChild, ContentChildren, NgModule, QueryList} from '@angular/core';\n            import {SomeDirective} from './some.directive';\n\n            @Component({\n              selector: 'content-query-component',\n              template: `\n                <div><ng-content></ng-content></div>\n              `\n            })\n            export class ContentQueryComponent {\n              @ContentChild(SomeDirective) someDir: SomeDirective;\n              @ContentChildren(SomeDirective) someDirList !: QueryList<SomeDirective>;\n            }\n\n            @Component({\n              selector: 'my-app',\n              template: `\n                <content-query-component>\n                  <div someDir></div>\n                </content-query-component>\n              `\n            })\n            export class MyApp { }\n\n            @NgModule({declarations: [SomeDirective, ContentQueryComponent, MyApp]})\n            export class MyModule { }\n            " })
                };
                var ContentQueryComponentDefinition = "\n          ContentQueryComponent.ngComponentDef = $r3$.\u0275defineComponent({\n            type: ContentQueryComponent,\n            selectors: [[\"content-query-component\"]],\n            factory: function ContentQueryComponent_Factory() {\n              return new ContentQueryComponent();\n            },            \n            contentQueries: function ContentQueryComponent_ContentQueries() {\n              $r3$.\u0275Qr($r3$.\u0275Q(null, SomeDirective, true));\n              $r3$.\u0275Qr($r3$.\u0275Q(null, SomeDirective, false));\n            },\n            contentQueriesRefresh: function ContentQueryComponent_ContentQueriesRefresh(dirIndex, queryStartIndex) {  \n              const instance = $r3$.\u0275d(dirIndex);\n              var $tmp$;\n              ($r3$.\u0275qR(($tmp$ = $r3$.\u0275ql(queryStartIndex))) && ($instance$.someDir = $tmp$.first));\n              ($r3$.\u0275qR(($tmp$ = $r3$.\u0275ql((queryStartIndex + 1)))) && ($instance$.someDirList = $tmp$));\n            },\n            template: function ContentQueryComponent_Template(rf, ctx) {\n              if (rf & 1) {\n                $r3$.\u0275pD();\n                $r3$.\u0275E(0, \"div\");\n                $r3$.\u0275P(1);\n                $r3$.\u0275e();\n              }\n            }\n          });";
                var result = mock_compile_1.compile(files, angularFiles);
                var source = result.source;
                mock_compile_1.expectEmit(source, ContentQueryComponentDefinition, 'Invalid ContentQuery declaration');
            });
        });
        describe('pipes', function () {
            var files = {
                app: {
                    'spec.ts': "\n              import {Component, NgModule, Pipe, PipeTransform, OnDestroy} from '@angular/core';\n\n              @Pipe({\n                name: 'myPipe',\n                pure: false\n              })\n              export class MyPipe implements PipeTransform,\n                  OnDestroy {\n                transform(value: any, ...args: any[]) { return value; }\n                ngOnDestroy(): void {  }\n              }\n\n              @Pipe({\n                name: 'myPurePipe',\n                pure: true,\n              })\n              export class MyPurePipe implements PipeTransform {\n                transform(value: any, ...args: any[]) { return value; }\n              }\n\n              @Component({\n                selector: 'my-app',\n                template: '{{name | myPipe:size | myPurePipe:size }}<p>{{ name | myPipe:1:2:3:4:5 }}</p>'\n              })\n              export class MyApp {\n                name = 'World';\n                size = 0;\n              }\n\n              @NgModule({declarations:[MyPipe, MyPurePipe, MyApp]})\n              export class MyModule {}\n          "
                }
            };
            it('should render pipes', function () {
                var MyPipeDefinition = "\n            MyPipe.ngPipeDef = $r3$.\u0275definePipe(\n                {name: \"myPipe\", type: MyPipe, factory: function MyPipe_Factory() { return new MyPipe(); }, pure: false});\n        ";
                var MyPurePipeDefinition = "\n            MyPurePipe.ngPipeDef = $r3$.\u0275definePipe({\n              name: \"myPurePipe\",\n              type: MyPurePipe,\n              factory: function MyPurePipe_Factory() { return new MyPurePipe(); },\n              pure: true\n            });";
                var MyAppDefinition = "\n            const $c0$ = function ($a0$) {\n              return [$a0$, 1, 2, 3, 4, 5];\n            };\n            // ...\n            MyApp.ngComponentDef = $r3$.\u0275defineComponent({\n              type: MyApp,\n              selectors: [[\"my-app\"]],\n              factory: function MyApp_Factory() { return new MyApp(); },\n              template: function MyApp_Template(rf, ctx) {\n                if (rf & 1) {\n                  $r3$.\u0275T(0);\n                  $r3$.\u0275Pp(1, \"myPurePipe\");\n                  $r3$.\u0275Pp(2, \"myPipe\");\n                  $r3$.\u0275E(3, \"p\");\n                  $r3$.\u0275T(4);\n                  $r3$.\u0275Pp(5, \"myPipe\");\n                  $r3$.\u0275e();\n                  $r3$.\u0275rS(15);\n                }\n                if (rf & 2) {\n                  $r3$.\u0275t(0, $r3$.\u0275i1(\"\", $r3$.\u0275pb2(1, 3, $r3$.\u0275pb2(2, 6, ctx.name, ctx.size), ctx.size), \"\"));\n                  $r3$.\u0275t(4, $r3$.\u0275i1(\"\", $r3$.\u0275pbV(5, 13 , $r3$.\u0275f1(15, $c0$, ctx.name)), \"\"));\n                }\n              },\n              pipes: [MyPurePipe, MyPipe]\n            });";
                var result = mock_compile_1.compile(files, angularFiles);
                var source = result.source;
                mock_compile_1.expectEmit(source, MyPipeDefinition, 'Invalid pipe definition');
                mock_compile_1.expectEmit(source, MyPurePipeDefinition, 'Invalid pure pipe definition');
                mock_compile_1.expectEmit(source, MyAppDefinition, 'Invalid MyApp definition');
            });
        });
        it('local reference', function () {
            var files = {
                app: {
                    'spec.ts': "\n            import {Component, NgModule} from '@angular/core';\n\n            @Component({selector: 'my-component', template: '<input #user>Hello {{user.value}}!'})\n            export class MyComponent {}\n\n            @NgModule({declarations: [MyComponent]})\n            export class MyModule {}\n          "
                }
            };
            var MyComponentDefinition = "\n        const $c1$ = [\"user\", \"\"];\n        \u2026\n        MyComponent.ngComponentDef = $r3$.\u0275defineComponent({\n          type: MyComponent,\n          selectors: [[\"my-component\"]],\n          factory: function MyComponent_Factory() { return new MyComponent(); },\n          template: function MyComponent_Template(rf, ctx) {\n            if (rf & 1) {\n              $r3$.\u0275Ee(0, \"input\", null, $c1$);\n              $r3$.\u0275T(2);\n            }\n            const $user$ = $r3$.\u0275ld(1);\n            if (rf & 2) {\n              $r3$.\u0275t(2, $r3$.\u0275i1(\"Hello \", $user$.value, \"!\"));\n            }\n          }\n        });\n      ";
            var result = mock_compile_1.compile(files, angularFiles);
            var source = result.source;
            mock_compile_1.expectEmit(source, MyComponentDefinition, 'Incorrect MyComponent.ngComponentDef');
        });
        describe('lifecycle hooks', function () {
            var files = {
                app: {
                    'spec.ts': "\n            import {Component, Input, NgModule} from '@angular/core';\n\n            let events: string[] = [];\n\n            @Component({selector: 'lifecycle-comp', template: ''})\n            export class LifecycleComp {\n              @Input('name') nameMin: string;\n\n              ngOnChanges() { events.push('changes' + this.nameMin); }\n\n              ngOnInit() { events.push('init' + this.nameMin); }\n              ngDoCheck() { events.push('check' + this.nameMin); }\n\n              ngAfterContentInit() { events.push('content init' + this.nameMin); }\n              ngAfterContentChecked() { events.push('content check' + this.nameMin); }\n\n              ngAfterViewInit() { events.push('view init' + this.nameMin); }\n              ngAfterViewChecked() { events.push('view check' + this.nameMin); }\n\n              ngOnDestroy() { events.push(this.nameMin); }\n            }\n\n            @Component({\n              selector: 'simple-layout',\n              template: `\n                <lifecycle-comp [name]=\"name1\"></lifecycle-comp>\n                <lifecycle-comp [name]=\"name2\"></lifecycle-comp>\n              `\n            })\n            export class SimpleLayout {\n              name1 = '1';\n              name2 = '2';\n            }\n\n            @NgModule({declarations: [LifecycleComp, SimpleLayout]})\n            export class LifecycleModule {}\n          "
                }
            };
            it('should gen hooks with a few simple components', function () {
                var LifecycleCompDefinition = "\n          LifecycleComp.ngComponentDef = $r3$.\u0275defineComponent({\n            type: LifecycleComp,\n            selectors: [[\"lifecycle-comp\"]],\n            factory: function LifecycleComp_Factory() { return new LifecycleComp(); },\n            inputs: {nameMin: \"name\"},\n            features: [$r3$.\u0275NgOnChangesFeature],\n            template: function LifecycleComp_Template(rf, ctx) {}\n          });";
                var SimpleLayoutDefinition = "\n          SimpleLayout.ngComponentDef = $r3$.\u0275defineComponent({\n            type: SimpleLayout,\n            selectors: [[\"simple-layout\"]],\n            factory: function SimpleLayout_Factory() { return new SimpleLayout(); },\n            template: function SimpleLayout_Template(rf, ctx) {\n              if (rf & 1) {\n                $r3$.\u0275Ee(0, \"lifecycle-comp\");\n                $r3$.\u0275Ee(1, \"lifecycle-comp\");\n              }\n              if (rf & 2) {\n                $r3$.\u0275p(0, \"name\", $r3$.\u0275b(ctx.name1));\n                $r3$.\u0275p(1, \"name\", $r3$.\u0275b(ctx.name2));\n              }\n            },\n            directives: [LifecycleComp]\n          });";
                var result = mock_compile_1.compile(files, angularFiles);
                var source = result.source;
                mock_compile_1.expectEmit(source, LifecycleCompDefinition, 'Invalid LifecycleComp definition');
                mock_compile_1.expectEmit(source, SimpleLayoutDefinition, 'Invalid SimpleLayout definition');
            });
        });
        describe('template variables', function () {
            var shared = {
                shared: {
                    'for_of.ts': "\n            import {Directive, Input, SimpleChanges, TemplateRef, ViewContainerRef} from '@angular/core';\n\n            export interface ForOfContext {\n              $implicit: any;\n              index: number;\n              even: boolean;\n              odd: boolean;\n            }\n\n            @Directive({selector: '[forOf]'})\n            export class ForOfDirective {\n              private previous: any[];\n\n              constructor(private view: ViewContainerRef, private template: TemplateRef<any>) {}\n\n              @Input() forOf: any[];\n\n              ngOnChanges(simpleChanges: SimpleChanges) {\n                if ('forOf' in simpleChanges) {\n                  this.update();\n                }\n              }\n\n              ngDoCheck(): void {\n                const previous = this.previous;\n                const current = this.forOf;\n                if (!previous || previous.length != current.length ||\n                    previous.some((value: any, index: number) => current[index] !== previous[index])) {\n                  this.update();\n                }\n              }\n\n              private update() {\n                // TODO(chuckj): Not implemented yet\n                // this.view.clear();\n                if (this.forOf) {\n                  const current = this.forOf;\n                  for (let i = 0; i < current.length; i++) {\n                    const context = {$implicit: current[i], index: i, even: i % 2 == 0, odd: i % 2 == 1};\n                    // TODO(chuckj): Not implemented yet\n                    // this.view.createEmbeddedView(this.template, context);\n                  }\n                  this.previous = [...this.forOf];\n                }\n              }\n            }\n          "
                }
            };
            it('should support embedded views in the SVG namespace', function () {
                var files = {
                    app: __assign({}, shared, { 'spec.ts': "\n                  import {Component, NgModule} from '@angular/core';\n                  import {ForOfDirective} from './shared/for_of';\n\n                  @Component({\n                    selector: 'my-component',\n                    template: `<svg><g *for=\"let item of items\"><circle></circle></g></svg>`\n                  })\n                  export class MyComponent {\n                    items = [{ data: 42 }, { data: 42 }];\n                  }\n\n                  @NgModule({\n                    declarations: [MyComponent, ForOfDirective]\n                  })\n                  export class MyModule {}\n                " })
                };
                // TODO(benlesh): Enforce this when the directives are specified
                var ForDirectiveDefinition = "\n              ForOfDirective.ngDirectiveDef = $r3$.\u0275defineDirective({\n                type: ForOfDirective,\n                selectors: [[\"\", \"forOf\", \"\"]],\n                factory: function ForOfDirective_Factory() {\n                  return new ForOfDirective($r3$.\u0275injectViewContainerRef(), $r3$.\u0275injectTemplateRef());\n                },\n                features: [$r3$.\u0275NgOnChangesFeature],\n                inputs: {forOf: \"forOf\"}\n              });\n            ";
                var MyComponentDefinition = "\n              const $_c0$ = [\"for\",\"\",\"forOf\",\"\"];\n              \u2026\n              MyComponent.ngComponentDef = $r3$.\u0275defineComponent({\n                type: MyComponent,\n                selectors: [[\"my-component\"]],\n                factory: function MyComponent_Factory() { return new MyComponent(); },\n                template: function MyComponent_Template(rf, ctx){\n                  if (rf & 1) {\n                    $r3$.\u0275NS();\n                    $r3$.\u0275E(0,\"svg\");\n                    $r3$.\u0275C(1,MyComponent__svg_g_Template_1,null,$_c0$);\n                    $r3$.\u0275e();\n                  }\n                  if (rf & 2) { $r3$.\u0275p(1,\"forOf\",$r3$.\u0275b(ctx.items)); }\n                  function MyComponent__svg_g_Template_1(rf, ctx0) {\n                    if (rf & 1) {\n                      $r3$.\u0275NS();\n                      $r3$.\u0275E(0,\"g\");\n                      $r3$.\u0275Ee(1,\"circle\");\n                      $r3$.\u0275e();\n                    }\n                  }\n                },\n                directives: [ForOfDirective]\n              });\n            ";
                var result = mock_compile_1.compile(files, angularFiles);
                var source = result.source;
                // TODO(benlesh): Enforce this when the directives are specified
                // expectEmit(source, ForDirectiveDefinition, 'Invalid directive definition');
                mock_compile_1.expectEmit(source, MyComponentDefinition, 'Invalid component definition');
            });
            it('should support a let variable and reference', function () {
                var files = {
                    app: __assign({}, shared, { 'spec.ts': "\n              import {Component, NgModule} from '@angular/core';\n              import {ForOfDirective} from './shared/for_of';\n\n              @Component({\n                selector: 'my-component',\n                template: `<ul><li *for=\"let item of items\">{{item.name}}</li></ul>`\n              })\n              export class MyComponent {\n                items = [{name: 'one'}, {name: 'two'}];\n              }\n\n              @NgModule({\n                declarations: [MyComponent, ForOfDirective]\n              })\n              export class MyModule {}\n            " })
                };
                // TODO(chuckj): Enforce this when the directives are specified
                var ForDirectiveDefinition = "\n          ForOfDirective.ngDirectiveDef = $r3$.\u0275defineDirective({\n            type: ForOfDirective,\n            selectors: [[\"\", \"forOf\", \"\"]],\n            factory: function ForOfDirective_Factory() {\n              return new ForOfDirective($r3$.\u0275injectViewContainerRef(), $r3$.\u0275injectTemplateRef());\n            },\n            features: [$r3$.\u0275NgOnChangesFeature],\n            inputs: {forOf: \"forOf\"}\n          });\n        ";
                var MyComponentDefinition = "\n          const $_c0$ = [\"for\",\"\",\"forOf\",\"\"];\n          \u2026\n          MyComponent.ngComponentDef = $r3$.\u0275defineComponent({\n            type: MyComponent,\n            selectors: [[\"my-component\"]],\n            factory: function MyComponent_Factory() { return new MyComponent(); },\n            template: function MyComponent_Template(rf, ctx) {\n              if (rf & 1) {\n                $r3$.\u0275E(0, \"ul\");\n                $r3$.\u0275C(1, MyComponent_li_Template_1, null, $_c0$);\n                $r3$.\u0275e();\n              }\n              if (rf & 2) {\n                $r3$.\u0275p(1, \"forOf\", $r3$.\u0275b(ctx.items));\n              }\n\n              function MyComponent_li_Template_1(rf, ctx0) {\n                if (rf & 1) {\n                  $r3$.\u0275E(0, \"li\");\n                  $r3$.\u0275T(1);\n                  $r3$.\u0275e();\n                }\n                if (rf & 2) {\n                  const $item$ = ctx0.$implicit;\n                  $r3$.\u0275t(1, $r3$.\u0275i1(\"\", $item$.name, \"\"));\n                }\n              }\n            },\n            directives: [ForOfDirective]\n          });\n        ";
                var result = mock_compile_1.compile(files, angularFiles);
                var source = result.source;
                // TODO(chuckj): Enforce this when the directives are specified
                // expectEmit(source, ForDirectiveDefinition, 'Invalid directive definition');
                mock_compile_1.expectEmit(source, MyComponentDefinition, 'Invalid component definition');
            });
            it('should support accessing parent template variables', function () {
                var files = {
                    app: __assign({}, shared, { 'spec.ts': "\n              import {Component, NgModule} from '@angular/core';\n              import {ForOfDirective} from './shared/for_of';\n\n              @Component({\n                selector: 'my-component',\n                template: `\n                <ul>\n                  <li *for=\"let item of items\">\n                    <div>{{item.name}}</div>\n                    <ul>\n                      <li *for=\"let info of item.infos\">\n                        {{item.name}}: {{info.description}}\n                      </li>\n                    </ul>\n                  </li>\n                </ul>`\n              })\n              export class MyComponent {\n                items = [\n                  {name: 'one', infos: [{description: '11'}, {description: '12'}]},\n                  {name: 'two', infos: [{description: '21'}, {description: '22'}]}\n                ];\n              }\n\n              @NgModule({\n                declarations: [MyComponent, ForOfDirective]\n              })\n              export class MyModule {}\n            " })
                };
                var MyComponentDefinition = "\n          const $c1$ = [\"for\", \"\", \"forOf\", \"\"];\n          \u2026\n          MyComponent.ngComponentDef = $r3$.\u0275defineComponent({\n            type: MyComponent,\n            selectors: [[\"my-component\"]],\n            factory: function MyComponent_Factory() { return new MyComponent(); },\n            template: function MyComponent_Template(rf, ctx) {\n              if (rf & 1) {\n                $r3$.\u0275E(0, \"ul\");\n                $r3$.\u0275C(1, MyComponent_li_Template_1, null, $c1$);\n                $r3$.\u0275e();\n              }\n              if (rf & 2) {\n                $r3$.\u0275p(1, \"forOf\", $r3$.\u0275b(ctx.items));\n              }\n\n              function MyComponent_li_Template_1(rf, ctx0) {\n                if (rf & 1) {\n                  $r3$.\u0275E(0, \"li\");\n                  $r3$.\u0275E(1, \"div\");\n                  $r3$.\u0275T(2);\n                  $r3$.\u0275e();\n                  $r3$.\u0275E(3, \"ul\");\n                  $r3$.\u0275C(4, MyComponent_li_li_Template_4, null, $c1$);\n                  $r3$.\u0275e();\n                  $r3$.\u0275e();\n                }\n                if (rf & 2) {\n                  const $item$ = ctx0.$implicit;\n                  $r3$.\u0275t(2, $r3$.\u0275i1(\"\", IDENT.name, \"\"));\n                  $r3$.\u0275p(4, \"forOf\", $r3$.\u0275b(IDENT.infos));\n                }\n\n                function MyComponent_li_li_Template_4(rf, ctx1) {\n                  if (rf & 1) {\n                    $r3$.\u0275E(0, \"li\");\n                    $r3$.\u0275T(1);\n                    $r3$.\u0275e();\n                  }\n                  if (rf & 2) {\n                    const $item$ = ctx0.$implicit;\n                    const $info$ = ctx1.$implicit;\n                    $r3$.\u0275t(1, $r3$.\u0275i2(\" \", $item$.name, \": \", $info$.description, \" \"));\n                  }\n                }\n              }\n            },\n            directives: [ForOfDirective]\n          });";
                var result = mock_compile_1.compile(files, angularFiles);
                var source = result.source;
                mock_compile_1.expectEmit(source, MyComponentDefinition, 'Invalid component definition');
            });
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicjNfY29tcGlsZXJfY29tcGxpYW5jZV9zcGVjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29tcGlsZXItY2xpL3Rlc3QvY29tcGxpYW5jZS9yM19jb21waWxlcl9jb21wbGlhbmNlX3NwZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7OztBQUdILGtFQUEwRTtBQUMxRSwrQ0FBbUQ7QUFHbkQ7O0lBRUk7QUFDSixRQUFRLENBQUMscUJBQXFCLEVBQUU7SUFFOUIsSUFBTSxZQUFZLEdBQUcsaUJBQUssQ0FBQztRQUN6QixjQUFjLEVBQUUsSUFBSTtRQUNwQixpQkFBaUIsRUFBRSxLQUFLO1FBQ3hCLGFBQWEsRUFBRSxJQUFJO0tBQ3BCLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyxVQUFVLEVBQUU7UUFDbkIsRUFBRSxDQUFDLG1CQUFtQixFQUFFO1lBQ3RCLElBQU0sS0FBSyxHQUFHO2dCQUNaLEdBQUcsRUFBRTtvQkFDSCxTQUFTLEVBQUUsOGJBV1Y7aUJBQ0Y7YUFDRixDQUFDO1lBRUYscUNBQXFDO1lBQ3JDLElBQU0sT0FBTyxHQUFHLHVFQUF1RSxDQUFDO1lBRXhGLHFGQUFxRjtZQUNyRixJQUFNLFFBQVEsR0FBRyxxdEJBb0JoQixDQUFDO1lBR0YsSUFBTSxNQUFNLEdBQUcsc0JBQU8sQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFFNUMseUJBQVUsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1lBQ3hELHlCQUFVLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztRQUM1RCxDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyxzQkFBc0IsRUFBRTtZQUN6QixJQUFNLEtBQUssR0FBRztnQkFDWixHQUFHLEVBQUU7b0JBQ0gsU0FBUyxFQUFF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